<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苟富</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gaufoo.com/"/>
  <updated>2018-11-19T09:30:57.545Z</updated>
  <id>http://gaufoo.com/</id>
  
  <author>
    <name>Gaufoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《DDIA》读与记（一）</title>
    <link href="http://gaufoo.com/ddia-i/"/>
    <id>http://gaufoo.com/ddia-i/</id>
    <published>2018-11-19T09:26:00.000Z</published>
    <updated>2018-11-19T09:30:57.545Z</updated>
    
    <content type="html"><![CDATA[<p>开始读DDIA。</p>
<a id="more"></a>
<hr>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>再不更新博客，主页都要长草了。但暂时没想好要写些什么，毕竟在我的技能五芒星里，写文章这一块是缺掉的。</p>
<p>为什么突然想开始每天写些东西，算是一种对无趣生活的对抗吧。想看看自己能一直写多久，也许明天就写不下去了，倒也无所谓了。</p>
<p>一开始不能太难，要有个适应期，所以打算先写点读书笔记。于是就有了《DDIA》读书笔记系列。</p>
<hr>
<h1 id="为什么是DDIA"><a href="#为什么是DDIA" class="headerlink" title="为什么是DDIA"></a>为什么是DDIA</h1><p>DDIA，全称Designing Data-Intensive Application，一本讲数据型应用的高层次概括和指导的书。为什么选择看这本书？我曾学过Spark，也学过Akka，但在学的过程中，看不清楚自己想要解决什么问题，为了学而学，学不进去，学不透彻。所以找来这本数据型应用圣经，从上帝视角来看看整个概况，以清晰视野，明确方向。</p>
<hr>
<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>英文为主，中英混合。</p>
<hr>
<h1 id="第一章：可靠性，可扩展性，可维护性"><a href="#第一章：可靠性，可扩展性，可维护性" class="headerlink" title="第一章：可靠性，可扩展性，可维护性"></a>第一章：可靠性，可扩展性，可维护性</h1><p>A data-intensive application is typically built from standard building blocks that provide commonly needed functionality. Many applications need to:</p>
<ul>
<li>Store data so that they, or another application, can find it again later (<em>databases</em>)</li>
<li>Remember the result of an expensive operation, to speed up reads (<em>caches</em>)</li>
<li>Allow users to search data by keyword or filter it in various ways (<em>search indexes</em>)</li>
<li>Send a message to another process, to be handled asynchronously (<em>stream processing</em>)</li>
<li>Periodically crunch a large amount of accumulated data (<em>batch processing</em>)</li>
</ul>
<p><br><br>Three concerns that are important in most software systems:</p>
<p><strong>Reliability</strong><br>The system should continue to work corrently (performing the correct function at the desired level of performance) even in the face of adversity (hardware or software faults, and even human error).</p>
<p><strong>Scalability</strong><br>As the system grows (in data volume, traffic volume, or complexity), there should be resonable ways of dealing with that growth.</p>
<p><strong>Maintainability</strong><br>Over time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new use cases), and they shold all be able to work on it productively.</p>
<hr>
<h2 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h2><ul>
<li>The application performs the function that the user expected.</li>
<li>It can tolerate the user making mistakes or using the software in unexpected ways.</li>
<li>Its performance is good enough for the required use case, under the expected load and data volume.</li>
<li>The system prevents any unauthorized access and abuse.</li>
</ul>
<blockquote>
<p>“continuing to work corrently, even when things go wrong.”</p>
</blockquote>
<p>不是所有fault都能容忍的，it only makes sense to talk about tolerating certain types of faults. 比如地球突然蒸发所造成的影响，基本上是恢复不了的。</p>
<p>Note that a fault is not the same as failure. A fault is usually defined as one component of the system deviating from its spec, whereas a failure is when the the system as a whole stops providing the required service to the user.<br>It usually best to design fault-tolerance mechanisms that prevent faults from causing failures.</p>
<h3 id="Hardware-Faults"><a href="#Hardware-Faults" class="headerlink" title="Hardware Faults"></a>Hardware Faults</h3><p>对于硬件错误，我们常常想到用redundancy来解决问题。Disks may be set up in a RAID configuration, servers may have dual power supplies and hot-swappable CPUs, and datacenters may have batteries and diesel generators for backup power.<br>尽管这些方法不能完全避免硬件问题所造成的failures，但足够简单易懂，and can often keep a machine running uninterrupted for years.</p>
<h3 id="Software-Errors"><a href="#Software-Errors" class="headerlink" title="Software Errors"></a>Software Errors</h3><p>系统里面的系统级错误是另外一种类型的fault。Such faults are harder to anticipate, and because they are correlated across nodes, they tend to cause many more system failures than uncorrelated hardware faults.</p>
<p>对于软件错误，没有什么万能灵药。但是可以关注这些事情：</p>
<ul>
<li>Carefully thinking about assumptions and interactions in the system</li>
<li>Process isolation</li>
<li>Allowing processes to crash and restart</li>
<li>Measuring, monitoring, and analyzing system behavior in production</li>
</ul>
<h3 id="Human-Errors"><a href="#Human-Errors" class="headerlink" title="Human Errors"></a>Human Errors</h3><p>是人就会犯错，one study of large internet services found that configuration errors by operators were the leading cause of outages.</p>
<p>To make our systems reliable, in spite of unreliable humans:</p>
<ul>
<li>Design systems in a way that minimizes opportunities for error. 好的abstractions, APIs, admin interfaces等等。</li>
<li>Decouple the places where people make the most mistakes from the places where they can cause failure. 提供fully featured non-production sandbox environments where 人类可以在里面胡作非为。</li>
<li>Test thoroughly at all levels, from unit tests to whole-system integration tests and manual tests.</li>
<li>Allow quick and easy recovery from human errors, to minimize the impact in the case of a failure.</li>
<li>Set up detailed and clear monitoring, such as performance metrics and error rates.</li>
<li>做好培训</li>
</ul>
<hr>
<h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p><em>Scalability</em> is the term we use to describe a system’s ability to cope with increased load.</p>
<p>讨论scalability，我们实际上说的是，”If the system grows in a particular way, what are our options for coping with the growth?” 以及 “How can we add computing resources to handle the additional load?”</p>
<h3 id="Describing-Load"><a href="#Describing-Load" class="headerlink" title="Describing Load"></a>Describing Load</h3><p>我们需要描述load，实际上我们描述的这些数字叫做<em>load parameters</em>。不同的<em>load parameters</em>取决于the architecture of your system: it may be requests per second to a web server, the ratio of reads to writes in a database, the number of simultaneously active users in a chat room等等</p>
<p>拿Twitter做例子，他们所描述的是：</p>
<ul>
<li>Post tweet: A user can publish a new message to their followers (4.6k requests/sec on average, over 12k requests/sec at peak).</li>
<li>Home timeline: A user can view tweets posts by the people they follow (300k requests/sec).</li>
</ul>
<h3 id="Describing-Performance"><a href="#Describing-Performance" class="headerlink" title="Describing Performance"></a>Describing Performance</h3><p>当你已经描述了load on your system, you can investigate what happens when the load increases.</p>
<ul>
<li>When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected?</li>
<li>When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged?</li>
</ul>
<p>In a batch processing system such as Hadoop, we usually care about throughput. In online systems, what’s usually more important is the service’s response time.</p>
<p>不是每次请求的响应时间都是一样的。We therefore need to think of response time not as single number, but as a distribution of values that you can measure.</p>
<p>Usually it is better to use <em>percentiles</em> which 描述了有多少比例的responses不超过该响应时间。The median is also known as the 50th percentile, and sometimes abbreviated as p50.</p>
<p>In order to figure out how bad your outliers are, you can look at higher percentiles: the 95th, 99th, 99.9th percentiles are common (abbribated p95, p99, and p999). They are the response time thresholds at which 95%, 99%, or 99.9% of requests are faster than that particular threshold. High percentiles of response times, also known as tail latencies, are important because they directly affect users’ experience of the service. </p>
<p>Percentiles are often used in service level objectives (SLOs) and service level agreements (SLAs), contracts that define the expected performance and availability of a service. 比如Amazon就用p999来描述他们的服务。These metrics set expectations for clients of the service and allow customers to demand a refund if the SLA is not met.</p>
<h3 id="Approaches-for-Coping-with-Load"><a href="#Approaches-for-Coping-with-Load" class="headerlink" title="Approaches for Coping with Load"></a>Approaches for Coping with Load</h3><p>To maintain good performance even when our load parameters increase by some amount, people often talk of a dichotomy between <em>scaling up</em> (vertical scaling, moving to a more powerful machine) and <em>scaling out</em> (horizontal scaling, distributing the load across multiple smaller machines).</p>
<p>While distributing stateless services across multiple machines is fairly straightforward, taking stateful data systems from a single node to a distributed setup can introduce a lot of additional complexity. For this reason, common wisdom until recently was to keep your database on a single node (scala up) until scaling cost or high-availability requirements forced you to make it distributed.</p>
<hr>
<h2 id="Maintainability"><a href="#Maintainability" class="headerlink" title="Maintainability"></a>Maintainability</h2><p>software system三个设计原则：</p>
<h3 id="Operability-Make-Lift-Easy-for-Operations"><a href="#Operability-Make-Lift-Easy-for-Operations" class="headerlink" title="Operability: Make Lift Easy for Operations"></a>Operability: Make Lift Easy for Operations</h3><p>Make it easy for operations teams to keep the system running smoothly.</p>
<h3 id="Simplicity-Managing-Complexity"><a href="#Simplicity-Managing-Complexity" class="headerlink" title="Simplicity: Managing Complexity"></a>Simplicity: Managing Complexity</h3><p>Make it easy for new engineers to understand the system the system, by removing as much complexity as possible from the system. 利用抽象，消除额外复杂度。</p>
<h3 id="Evolvability-Making-Change-Easy"><a href="#Evolvability-Making-Change-Easy" class="headerlink" title="Evolvability: Making Change Easy"></a>Evolvability: Making Change Easy</h3><p>Make it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change. Also known as extensibility, modifiability, or plasticity. Agile working patterns provide a framework for adapting to change. 比如test-driven development (TDD) and refactoring.</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始读DDIA。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://gaufoo.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="DDIA" scheme="http://gaufoo.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
      <category term="大数据" scheme="http://gaufoo.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="DDIA" scheme="http://gaufoo.com/tags/DDIA/"/>
    
      <category term="读书笔记" scheme="http://gaufoo.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AWK常见用法</title>
    <link href="http://gaufoo.com/awk/"/>
    <id>http://gaufoo.com/awk/</id>
    <published>2018-09-08T18:45:35.000Z</published>
    <updated>2018-09-08T18:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>AWK是GUN/Linux下的其中一个文本处理工具，简洁又强大。</p>
<a id="more"></a>
<hr>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; ??? &#125;</div></pre></td></tr></table></figure>
<p>可选，awk程序启动时执行一次。</p>
<h2 id="循环块"><a href="#循环块" class="headerlink" title="循环块"></a>循环块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/pattern/ &#123; ??? &#125;</div></pre></td></tr></table></figure>
<p><code>pattern</code>为正则表达式</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">END &#123; ??? &#125;</div></pre></td></tr></table></figure>
<p>可选，结束时执行一次。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ cat &gt;&gt; marks.txt</div><div class="line">1)    Amit     Physics    80</div><div class="line">2)    Rahul    Maths      90</div><div class="line">3)    Shyam    Biology    87</div><div class="line">4)    Kedar    English    85</div><div class="line">5)    Hari     History    89</div><div class="line">$ awk &apos;BEGIN&#123;printf &quot;Sr No\tName\tSub\tMarks\n&quot;&#125; &#123;print&#125;&apos; marks.txt </div><div class="line">Sr No	Name	Sub	Marks</div><div class="line">1)    Amit     Physics    80</div><div class="line">2)    Rahul    Maths      90</div><div class="line">3)    Shyam    Biology    87</div><div class="line">4)    Kedar    English    85</div><div class="line">5)    Hari     History    89</div></pre></td></tr></table></figure>
<hr>
<h1 id="辅助选项"><a href="#辅助选项" class="headerlink" title="辅助选项"></a>辅助选项</h1><h2 id="加载脚本文件"><a href="#加载脚本文件" class="headerlink" title="加载脚本文件"></a>加载脚本文件</h2><p><code>-f ???</code> 或 <code>--file=???</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ cat &gt;&gt; command.awk</div><div class="line">BEGIN &#123;</div><div class="line">	printf &quot;Sr No\tName\tSub\tMarks\n&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">	print</div><div class="line">&#125;</div><div class="line">$ awk -f command.awk marks.txt </div><div class="line">Sr No	Name	Sub	Marks</div><div class="line">1)    Amit     Physics    80</div><div class="line">2)    Rahul    Maths      90</div><div class="line">3)    Shyam    Biology    87</div><div class="line">4)    Kedar    English    85</div><div class="line">5)    Hari     History    89</div></pre></td></tr></table></figure></p>
<h2 id="预先分配变量"><a href="#预先分配变量" class="headerlink" title="预先分配变量"></a>预先分配变量</h2><p><code>-v var=???</code> 或 <code>--assign=var=???</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk -v name=Jerry &apos;BEGIN&#123;printf &quot;Name = %s\n&quot;, name&#125;&apos;</div><div class="line">Name = Jerry</div></pre></td></tr></table></figure></p>
<h2 id="预先指定分隔符"><a href="#预先指定分隔符" class="headerlink" title="预先指定分隔符"></a>预先指定分隔符</h2><p><code>-F ???</code> 或 <code>--field-separator=???</code><br>指定多个分隔符： <code>-F &#39;[:,./]&#39;</code></p>
<hr>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><h2 id="打印指定列"><a href="#打印指定列" class="headerlink" title="打印指定列"></a>打印指定列</h2><p>打印第3、4列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123;print $3 &quot;\t&quot; $4&#125;&apos; marks.txt </div><div class="line">Physics	80</div><div class="line">Maths	90</div><div class="line">Biology	87</div><div class="line">English	85</div><div class="line">History	89</div></pre></td></tr></table></figure></p>
<h2 id="打印模式匹配行"><a href="#打印模式匹配行" class="headerlink" title="打印模式匹配行"></a>打印模式匹配行</h2><p>含<code>a</code>的所有行，正则表达式语法和bash一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;/a/ &#123;print $0&#125;&apos; marks.txt </div><div class="line">2)    Rahul    Maths      90</div><div class="line">3)    Shyam    Biology    87</div><div class="line">4)    Kedar    English    85</div><div class="line">5)    Hari     History    89</div><div class="line"></div><div class="line"># 或</div><div class="line"># $ awk &apos;/a/&apos; marks.txt</div></pre></td></tr></table></figure></p>
<p>正则表达式语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/^abc/     表示以abc开头，其中^表示在行首位置进行匹配。</div><div class="line">/abc$/     表示以abc结尾，其中$表示在行尾位置进行匹配。</div><div class="line">/abc/      表示当前记录行中出现了abc串。</div><div class="line">/[a-d]/    表示与a-d中的任意一个字符匹配。即当前行中只要有a-d中的任意一个字符就匹配成功。</div><div class="line">/[acwy]/   表示与a、c、w、y中的任意一个字符匹配。即当前行中只要有a、c、w、y中的任意一个字符就匹配成功。</div><div class="line">/[^a-d]/   表示不与a-d中的任意一个字符做匹配。</div><div class="line">/cut|pot/  表示与cut匹配或与pot匹配。</div><div class="line">/[ABC]*/   表示与A、B、C中任意一个出现0次或多次的字符相匹配。</div><div class="line">/[ABC]+/   表示与A、B、C中任意一个出现1次或多次的字符相匹配。</div><div class="line">/./        表示任意一个字符，“.”表示任意一个字符。</div></pre></td></tr></table></figure></p>
<h2 id="打印匹配行指定列"><a href="#打印匹配行指定列" class="headerlink" title="打印匹配行指定列"></a>打印匹配行指定列</h2><p>含<code>a</code>的所有行里，打印第3,4列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;/a/ &#123;print $3 &quot;\t&quot; $4&#125;&apos; marks.txt </div><div class="line">Maths	90</div><div class="line">Biology	87</div><div class="line">English	85</div><div class="line">History	89</div></pre></td></tr></table></figure></p>
<h2 id="打印符合条件行"><a href="#打印符合条件行" class="headerlink" title="打印符合条件行"></a>打印符合条件行</h2><p>长度大于18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;length($0) &gt; 18 &#123;print&#125;&apos; marks.txt</div><div class="line"></div><div class="line"># 或</div><div class="line"># $ awk &apos;length($0) &gt; 18&apos; marks.txt</div></pre></td></tr></table></figure></p>
<h2 id="不止打印"><a href="#不止打印" class="headerlink" title="不止打印"></a>不止打印</h2><p>统计含<code>a</code>的行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk -v cnt=0 &apos;/a/ &#123; ++cnt &#125; END &#123; print &quot;Count = &quot; cnt&#125;&apos; marks.txt </div><div class="line">Count = 4</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="FILENAME"><a href="#FILENAME" class="headerlink" title="FILENAME"></a>FILENAME</h2><p>当前文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;END &#123;print FILENAME&#125;&apos; marks.txt </div><div class="line">marks.txt</div></pre></td></tr></table></figure></p>
<p>在<code>BEGIN</code>块未定义</p>
<h2 id="FS-OFS"><a href="#FS-OFS" class="headerlink" title="FS OFS"></a>FS OFS</h2><p>域分隔符：读取输入时分割<br>输出域分隔符：输出时分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk -F; &apos;END &#123;print &quot;FS = &quot; FS&#125;&apos; marks.txt </div><div class="line">FS = ;</div></pre></td></tr></table></figure></p>
<h2 id="RS-ORS"><a href="#RS-ORS" class="headerlink" title="RS ORS"></a>RS ORS</h2><p>行分隔符<br>输出行分隔符</p>
<h2 id="NF"><a href="#NF" class="headerlink" title="NF"></a>NF</h2><p>number of field，当前行总域数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123;print NF&#125;&apos; marks.txt </div><div class="line">4</div><div class="line">4</div><div class="line">4</div><div class="line">4</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>只打印一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;END &#123;print NF&#125;&apos; marks.txt </div><div class="line">4</div></pre></td></tr></table></figure></p>
<h2 id="NR"><a href="#NR" class="headerlink" title="NR"></a>NR</h2><p>number of input records，当前行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123;print NR&#125;&apos; marks.txt </div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure></p>
<p>总行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;END &#123;print NR&#125;&apos; marks.txt </div><div class="line">5</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;BEGIN &#123; a = 10; b = 20.1; print (a + b) &#125;&apos;</div><div class="line">30.1</div></pre></td></tr></table></figure>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;BEGIN &#123; a = 10; b = 20.1; print (a != b)&#125;&apos; </div><div class="line">1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;BEGIN &#123; a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max&#125;&apos;</div><div class="line">Max = 20</div></pre></td></tr></table></figure>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;BEGIN &#123; str1=&quot;Hello, &quot;; str2=&quot;World&quot;; str3 = str1 str2; print str3 &#125;&apos;</div><div class="line">Hello, World</div></pre></td></tr></table></figure>
<h2 id="模式匹配符"><a href="#模式匹配符" class="headerlink" title="模式匹配符"></a>模式匹配符</h2><p>匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;$0 ~ 9&apos; marks.txt </div><div class="line">2)    Rahul    Maths      90</div><div class="line">5)    Hari     History    89</div><div class="line"></div><div class="line"># 等价于</div><div class="line"># awk &apos;/9/&apos; marks.txt</div></pre></td></tr></table></figure></p>
<p>不匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;$0 !~ 9&apos; marks.txt </div><div class="line">1)    Amit     Physics    80</div><div class="line">3)    Shyam    Biology    87</div><div class="line">4)    Kedar    English    85</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><p><code>if-elseif-else</code>，<code>while</code>，<code>for</code>，<code>do-while</code>等，和C语言类似。<br><code>for (i in array)</code>用于遍历数组。</p>
<hr>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><h2 id="length-str"><a href="#length-str" class="headerlink" title="length(str)"></a>length(str)</h2><p>字符串长度</p>
<h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><p>返回[0, 1)之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;BEGIN &#123; print rand() &#125;&apos;</div><div class="line">0.757217</div></pre></td></tr></table></figure></p>
<h2 id="gsub-regex-sub-str-0"><a href="#gsub-regex-sub-str-0" class="headerlink" title="gsub(regex, sub, str=$0)"></a>gsub(regex, sub, str=$0)</h2><p>全局替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; gsub(&quot;a&quot;, &quot;A&quot;); print &#125;&apos; marks.txt </div><div class="line">1)    Amit     Physics    80</div><div class="line">2)    RAhul    MAths      90</div><div class="line">3)    ShyAm    Biology    87</div><div class="line">4)    KedAr    English    85</div><div class="line">5)    HAri     History    89</div></pre></td></tr></table></figure></p>
<h2 id="sub-regex-sub-str-0"><a href="#sub-regex-sub-str-0" class="headerlink" title="sub(regex, sub, str=$0)"></a>sub(regex, sub, str=$0)</h2><p>替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; sub(&quot;a&quot;, &quot;A&quot;); print &#125;&apos; marks.txt </div><div class="line">1)    Amit     Physics    80</div><div class="line">2)    RAhul    Maths      90</div><div class="line">3)    ShyAm    Biology    87</div><div class="line">4)    KedAr    English    85</div><div class="line">5)    HAri     History    89</div></pre></td></tr></table></figure></p>
<h2 id="index-str-sub"><a href="#index-str-sub" class="headerlink" title="index(str, sub)"></a>index(str, sub)</h2><p>子串首次匹配位置，从1开始计数，匹配不到返回0。</p>
<h2 id="match-str-regex"><a href="#match-str-regex" class="headerlink" title="match(str, regex)"></a>match(str, regex)</h2><p>和<code>index</code>类似，但是匹配正则表达式。</p>
<h2 id="substr-str-start-length"><a href="#substr-str-start-length" class="headerlink" title="substr(str, start, length)"></a>substr(str, start, length)</h2><p>按位置和长度截取字符串。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWK是GUN/Linux下的其中一个文本处理工具，简洁又强大。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://gaufoo.com/categories/Linux/"/>
    
      <category term="awk" scheme="http://gaufoo.com/categories/Linux/awk/"/>
    
    
      <category term="Linux" scheme="http://gaufoo.com/tags/Linux/"/>
    
      <category term="awk" scheme="http://gaufoo.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>采用Hibench在本地对Spark Streaming进行benchmark</title>
    <link href="http://gaufoo.com/spark_bench/"/>
    <id>http://gaufoo.com/spark_bench/</id>
    <published>2018-07-23T20:16:12.000Z</published>
    <updated>2018-07-23T21:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文祭奠过去三天起起落落的辛酸经历。</p>
<a id="more"></a>
<hr>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>此间与无数Error碰面，奈何benchmark稍显冷门，任凭我历尽多种方法，于谷歌、百度、必应等知名搜索引擎也寻找无果。在翻阅<strong>HiBench</strong>的<a href="https://github.com/intel-hadoop/HiBench/issues" target="_blank" rel="external">Github Issues</a>时，甚至发现与我相同的问题存在数个月之久无人问津，乃至于后来我写邮件求助亦如石沉大海。幸而我时常有灵光乍现的时刻，总会在经历一遍又一遍的试错后，偶得正确解决方案，最终克服了所有的问题，解决掉所有的Error，成功运行Benchmark，作文以记之。</p>
<hr>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul>
<li><strong>java</strong> 1.8<br>终端运行<br><code>$ sudo apt update &amp;&amp; sudo apt install openjdk-8-jdk</code></li>
<li><strong>scala</strong> 2.11.8<br><a href="https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz" target="_blank" rel="external">https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz</a><br>下载并解压二进制包</li>
<li><strong>hadoop</strong> 2.8.3<br><a href="http://archive.apache.org/dist/hadoop/common/hadoop-2.8.3/hadoop-2.8.3.tar.gz" target="_blank" rel="external">http://archive.apache.org/dist/hadoop/common/hadoop-2.8.3/hadoop-2.8.3.tar.gz</a><br>下载并解压二进制包</li>
<li><strong>spark</strong> 2.2.2<br><a href="https://www.apache.org/dyn/closer.lua/spark/spark-2.2.2/spark-2.2.2-bin-hadoop2.7.tgz" target="_blank" rel="external">https://www.apache.org/dyn/closer.lua/spark/spark-2.2.2/spark-2.2.2-bin-hadoop2.7.tgz</a><br>下载并解压二进制包</li>
<li><strong>zookeeper</strong> 3.4.10<br><a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz" target="_blank" rel="external">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</a><br>下载并解压二进制包</li>
<li><strong>kafka</strong> 2.11-0.8.2.2<br><a href="https://archive.apache.org/dist/kafka/0.8.2.2/kafka_2.11-0.8.2.2.tgz" target="_blank" rel="external">https://archive.apache.org/dist/kafka/0.8.2.2/kafka_2.11-0.8.2.2.tgz</a><br>下载并解压二进制包</li>
<li><strong>maven</strong>    3.3.9<br>终端运行<br><code>$ sudo apt update &amp;&amp; sudo apt install maven</code></li>
<li>hibench 7.0<br><a href="https://github.com/intel-hadoop/HiBench" target="_blank" rel="external">https://github.com/intel-hadoop/HiBench</a><br>clone下来或者下载解压zip</li>
</ul>
<p>下载解压到某目录后，设置好路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit ~/.bashrc</div></pre></td></tr></table></figure></p>
<p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64</div><div class="line"></div><div class="line">export SCALA_HOME=/目录/scala-2.11.8</div><div class="line">export PATH=$PATH:$SCALA_HOME/bin</div><div class="line"></div><div class="line">export HADOOP_HOME=/目录/hadoop-2.8.3</div><div class="line"></div><div class="line">export SPARK_HOME=/目录/spark-2.2.2</div><div class="line">export PATH=$PATH:$SPARK_HOME/bin</div><div class="line"></div><div class="line">export ZOOKEEPER_HOME=/目录/zookeeper-3.4.10</div><div class="line"></div><div class="line">export KAFKA_HOME=/目录/kafka_2.11-0.8.2.2</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source ~/.bashrc</div></pre></td></tr></table></figure>
<p>生效</p>
<hr>
<h1 id="配置软件"><a href="#配置软件" class="headerlink" title="配置软件"></a>配置软件</h1><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="进入文件夹"><a href="#进入文件夹" class="headerlink" title="进入文件夹"></a>进入文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd $HADOOP_HOME</div></pre></td></tr></table></figure>
<hr>
<h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><h4 id="配置hadoop-env-sh"><a href="#配置hadoop-env-sh" class="headerlink" title="配置hadoop-env.sh"></a>配置hadoop-env.sh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit etc/hadoop/hadoop-env.sh</div></pre></td></tr></table></figure>
<p>将<code>JAVA_HOME</code>改成正确目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># set to the root of your Java installation</div><div class="line">export JAVA_HOME=/Java的所在目录</div></pre></td></tr></table></figure></p>
<h4 id="配置core-site-xml"><a href="#配置core-site-xml" class="headerlink" title="配置core-site.xml"></a>配置core-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit etc/hadoop/core-site.xml</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h4 id="配置hdfs-site-xml"><a href="#配置hdfs-site-xml" class="headerlink" title="配置hdfs-site.xml"></a>配置hdfs-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit etc/hadoop/hdfs-site.xml</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">        &lt;value&gt;1&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h4 id="确保ssh到localhost无需密码"><a href="#确保ssh到localhost无需密码" class="headerlink" title="确保ssh到localhost无需密码"></a>确保ssh到localhost无需密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh localhost</div></pre></td></tr></table></figure>
<p>否则执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -P &apos;&apos; -f ~/.ssh/id_rsa</div><div class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div><div class="line">$ chmod 0600 ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/hdfs namenode -format</div><div class="line">$ sbin/start-dfs.sh</div></pre></td></tr></table></figure>
<hr>
<h3 id="在yarn上运行"><a href="#在yarn上运行" class="headerlink" title="在yarn上运行"></a>在yarn上运行</h3><p>（这步是需要的，我之前没有执行，导致Hibench一直无法正确运行）</p>
<h4 id="配置mapred-site-xml"><a href="#配置mapred-site-xml" class="headerlink" title="配置mapred-site.xml"></a>配置mapred-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit etc/hadoop/mapred-site.xml</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">        &lt;value&gt;yarn&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h4 id="配置yarn-site-xml"><a href="#配置yarn-site-xml" class="headerlink" title="配置yarn-site.xml"></a>配置yarn-site.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit etc/hadoop/yarn-site.xml</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sbin/start-yarn.sh</div></pre></td></tr></table></figure>
<hr>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="进入文件夹-1"><a href="#进入文件夹-1" class="headerlink" title="进入文件夹"></a>进入文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd $ZOOKEEPER_HOME</div></pre></td></tr></table></figure>
<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp conf/zoo_sample.cfg conf/zoo.cfg</div></pre></td></tr></table></figure>
<h3 id="创建数据存储目录"><a href="#创建数据存储目录" class="headerlink" title="创建数据存储目录"></a>创建数据存储目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir /数据存储目录</div></pre></td></tr></table></figure>
<h3 id="配置数据存储目录"><a href="#配置数据存储目录" class="headerlink" title="配置数据存储目录"></a>配置数据存储目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit conf/zoo.cfg</div></pre></td></tr></table></figure>
<p>修改<code>dataDir</code>项为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dataDir=/你创建的目录</div></pre></td></tr></table></figure></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/zkServer.sh start</div></pre></td></tr></table></figure>
<hr>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="进入文件夹-2"><a href="#进入文件夹-2" class="headerlink" title="进入文件夹"></a>进入文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd $KAFKA_HOME</div></pre></td></tr></table></figure>
<h3 id="创建log目录"><a href="#创建log目录" class="headerlink" title="创建log目录"></a>创建log目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir /log目录</div></pre></td></tr></table></figure>
<h3 id="配置server-properties"><a href="#配置server-properties" class="headerlink" title="配置server.properties"></a>配置server.properties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit config/server.properties</div></pre></td></tr></table></figure>
<p>修改以下项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log.dirs=/你创建的目录</div></pre></td></tr></table></figure></p>
<h3 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h3><p>注意不要关闭终端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/kafka-server-start.sh config/server.properties</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="Hibench"><a href="#Hibench" class="headerlink" title="Hibench"></a>Hibench</h1><h2 id="Build-Hibench"><a href="#Build-Hibench" class="headerlink" title="Build Hibench"></a>Build Hibench</h2><p>进入Hibench源码目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn -Phadoopbench -Psparkbench -Dspark=2.2 -Dscala=2.11 clean package</div></pre></td></tr></table></figure></p>
<p>这里需要挺长一段时间</p>
<hr>
<h2 id="Hadoop-bench"><a href="#Hadoop-bench" class="headerlink" title="Hadoop bench"></a>Hadoop bench</h2><h3 id="配置hadoop-conf"><a href="#配置hadoop-conf" class="headerlink" title="配置hadoop.conf"></a>配置hadoop.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp conf/hadoop.conf.template conf/hadoop.conf</div><div class="line">$ gedit conf/hadoop.conf</div></pre></td></tr></table></figure>
<p>修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hibench.hadoop.home           /Hadoop所在目录/hadoop-2.8.3</div><div class="line">hibench.hdfs.master           hdfs://localhost:9000</div></pre></td></tr></table></figure></p>
<h3 id="尝试运行Hadoop负载测试"><a href="#尝试运行Hadoop负载测试" class="headerlink" title="尝试运行Hadoop负载测试"></a>尝试运行Hadoop负载测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/workloads/micro/wordcount/prepare/prepare.sh</div><div class="line">$ bin/workloads/micro/wordcount/hadoop/run.sh</div></pre></td></tr></table></figure>
<h3 id="查看报告"><a href="#查看报告" class="headerlink" title="查看报告"></a>查看报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ more report/hibench.report</div></pre></td></tr></table></figure>
<p>更详细数据在<br><code>report/identity/hadoop/bench.log</code><br><code>report/identity/hadoop/monitor.html</code></p>
<hr>
<h2 id="Spark-bench"><a href="#Spark-bench" class="headerlink" title="Spark bench"></a>Spark bench</h2><h3 id="配置spark-conf"><a href="#配置spark-conf" class="headerlink" title="配置spark.conf"></a>配置spark.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp conf/spark.conf.template conf/spark.conf</div><div class="line">$ gedit conf/spark.conf</div></pre></td></tr></table></figure>
<p>修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hibench.spark.home      /Spark所在目录/spark-2.2.2</div><div class="line">hibench.spark.master    local[*]</div></pre></td></tr></table></figure></p>
<h3 id="尝试运行Spark负载测试"><a href="#尝试运行Spark负载测试" class="headerlink" title="尝试运行Spark负载测试"></a>尝试运行Spark负载测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/workloads/micro/wordcount/prepare/prepare.sh</div><div class="line">$ bin/workloads/micro/wordcount/spark/run.sh</div></pre></td></tr></table></figure>
<h3 id="查看报告-1"><a href="#查看报告-1" class="headerlink" title="查看报告"></a>查看报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ more report/hibench.report</div></pre></td></tr></table></figure>
<hr>
<h2 id="Spark-Streaming-bench"><a href="#Spark-Streaming-bench" class="headerlink" title="Spark Streaming bench"></a>Spark Streaming bench</h2><h3 id="配置Kafka"><a href="#配置Kafka" class="headerlink" title="配置Kafka"></a>配置Kafka</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit conf/hibench.conf</div></pre></td></tr></table></figure>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hibench.streambench.kafka.home          /Kafka所在目录/kafka_2.11-0.8.2.2</div><div class="line"># zookeeper host:port of kafka cluster, host1:port1,host2:port2...</div><div class="line">hibench.streambench.zkHost              localhost:2181</div><div class="line"># Kafka broker lists, written in mode host:port,host:port,..</div><div class="line">hibench.streambench.kafka.brokerList    localhost:9092</div></pre></td></tr></table></figure></p>
<h3 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h3><h4 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/workloads/streaming/identity/prepare/genSeedDataset.sh</div></pre></td></tr></table></figure>
<p>这里会跑Hadoop，会占资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/workloads/streaming/identity/prepare/dataGen.sh</div></pre></td></tr></table></figure></p>
<p>这里开始就会一直发送数据，不要关闭</p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>这里注意把终端窗口拉长一些，以便找到Spark WebUI的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/workloads/streaming/identity/spark/run.sh</div></pre></td></tr></table></figure></p>
<p>浏览器打开 <a href="http://某ip:4040" target="_blank" rel="external">http://某ip:4040</a> 即可查看实时负载数据</p>
<p><img src="/images/180724/img.png"></p>
<h4 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/workloads/streaming/identity/common/metrics_reader.sh</div></pre></td></tr></table></figure>
<hr>
<h2 id="修改负载参数"><a href="#修改负载参数" class="headerlink" title="修改负载参数"></a>修改负载参数</h2><h3 id="修改数据量"><a href="#修改数据量" class="headerlink" title="修改数据量"></a>修改数据量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit conf/hibench.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hibench.streambench.datagen.intervalSpan	Interval span in millisecond (default: 50)</div><div class="line">hibench.streambench.datagen.recordsPerInterval	Number of records to generate per interval span (default: 5)</div><div class="line">hibench.streambench.datagen.recordLength	fixed length of record (default: 200)</div><div class="line">hibench.streambench.datagen.producerNumber	Number of KafkaProducer running on different thread (default: 1)</div><div class="line">hibench.streambench.datagen.totalRounds	Total round count of data send (default: -1 means infinity)</div><div class="line">hibench.streambench.datagen.totalRecords	Number of total records that will be generated (default: -1 means infinity)</div></pre></td></tr></table></figure>
<h3 id="修改spark配置"><a href="#修改spark配置" class="headerlink" title="修改spark配置"></a>修改spark配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gedit conf/spark.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># Spark streaming Batchnterval in millisecond (default 100)</div><div class="line">hibench.streambench.spark.batchInterval          800</div><div class="line"></div><div class="line"># Number of nodes that will receive kafka input (default: 4)</div><div class="line">hibench.streambench.spark.receiverNumber        4</div><div class="line"></div><div class="line"># Indicate RDD storage level. (default: 2)</div><div class="line"># 0 = StorageLevel.MEMORY_ONLY</div><div class="line"># 1 = StorageLevel.MEMORY_AND_DISK_SER</div><div class="line"># other = StorageLevel.MEMORY_AND_DISK_SER_2</div><div class="line">hibench.streambench.spark.storageLevel 2</div><div class="line"></div><div class="line"># indicate whether to test the write ahead log new feature (default: false)</div><div class="line">hibench.streambench.spark.enableWAL false</div><div class="line"></div><div class="line"># if testWAL is true, this path to store stream context in hdfs shall be specified. If false, it can be empty (default: /var/tmp)</div><div class="line">hibench.streambench.spark.checkpointPath /var/tmp</div><div class="line"></div><div class="line"># whether to use direct approach or not (dafault: true)</div><div class="line">hibench.streambench.spark.useDirectMode true</div></pre></td></tr></table></figure>
<hr>
<h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><p>为了避免磁盘被占满，应及时清理kafka和zookeeper产生的数据文件</p>
<hr>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://github.com/intel-hadoop/HiBench/blob/master/docs/build-hibench.md" target="_blank" rel="external">https://github.com/intel-hadoop/HiBench/blob/master/docs/build-hibench.md</a></li>
<li><a href="https://github.com/intel-hadoop/HiBench/blob/master/docs/run-sparkbench.md" target="_blank" rel="external">https://github.com/intel-hadoop/HiBench/blob/master/docs/run-sparkbench.md</a></li>
<li><a href="https://github.com/intel-hadoop/HiBench/blob/master/docs/run-streamingbench.md" target="_blank" rel="external">https://github.com/intel-hadoop/HiBench/blob/master/docs/run-streamingbench.md</a></li>
<li><a href="http://hadoop.apache.org/docs/r2.8.3/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.8.3/hadoop-project-dist/hadoop-common/SingleCluster.html</a></li>
<li><a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html" target="_blank" rel="external">https://zookeeper.apache.org/doc/current/zookeeperStarted.html</a></li>
<li><a href="https://kafka.apache.org/quickstart" target="_blank" rel="external">https://kafka.apache.org/quickstart</a></li>
</ol>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谨以此文祭奠过去三天起起落落的辛酸经历。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://gaufoo.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://gaufoo.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="http://gaufoo.com/tags/spark/"/>
    
      <category term="benchmark" scheme="http://gaufoo.com/tags/benchmark/"/>
    
      <category term="hibench" scheme="http://gaufoo.com/tags/hibench/"/>
    
  </entry>
  
  <entry>
    <title>fold right与fold left的相互转化</title>
    <link href="http://gaufoo.com/foldl-and-foldr/"/>
    <id>http://gaufoo.com/foldl-and-foldr/</id>
    <published>2018-05-19T04:58:51.000Z</published>
    <updated>2018-05-19T09:33:40.129Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文请自备纸、笔、头痛药。</p>
<a id="more"></a>
<hr>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><code>fold left</code>和<code>fold right</code>是函数式编程里表达遍历求值的其中一种重要表达式。在此不过多介绍，本文假设读者熟悉并能熟练使用<code>fold left</code>与<code>fold right</code>进行遍历求值。<br>问题来源于Scala小红书里一个小习题。大致意思是，如何利用<code>fold left</code>来实现<code>fold right</code>。一般人，包括我，第一直觉就是反转list，然后flip一下二元函数。</p>
<figure><img src="/images/180519/20180519131632.jpg" width="300"><figcaption>Fig.1 - 我和我的小伙伴都是这样想的</figcaption></figure>

<p>但是原文中还说了一句：</p>
<blockquote>
<p>用fold left来实现fold right很有用，因为可以用尾递归的方式实现，意味着无论列表有多长都不会产生栈溢出。</p>
</blockquote>
<p>那用reverse显然是不符合题意的，因为会导致栈溢出。好奇心驱使着我去寻找这个问题的正确解答，果不其然，我又被惊艳到了。</p>
<hr>
<h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 用foldl实现foldr</div><div class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</div><div class="line"><span class="title">foldr</span> f z xs = foldl (\g x -&gt; \z -&gt; g (f x z)) id xs z</div><div class="line"></div><div class="line">// 用foldr实现foldl</div><div class="line"><span class="title">foldl</span> :: <span class="type">Foldable</span> t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</div><div class="line"><span class="title">foldl</span> f z xs = foldr (\x g -&gt; \z -&gt; g (f z x)) id xs z</div></pre></td></tr></table></figure>
<p>如果能一下子看懂并理解，敬你是个天才。一开始看不懂、被绕晕也是正常的。欢迎参考我接下来的解析。</p>
<hr>
<h1 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h1><h2 id="fold-left"><a href="#fold-left" class="headerlink" title="fold left"></a>fold left</h2><p><code>foldl f z [1..10]</code>的求值形状如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10)</div></pre></td></tr></table></figure></p>
<h2 id="fold-right"><a href="#fold-right" class="headerlink" title="fold right"></a>fold right</h2><p><code>foldr f z [1..10]</code>的求值形状如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z))))))))))</div></pre></td></tr></table></figure></p>
<p>上述用<code>foldl</code>实现<code>foldr</code>本质上就是利用<code>foldl</code>生成<code>foldr</code>那样的一个求值形状（闭包），然后apply到初始值z上，求值那一长串得到最后结果，而用<code>foldr</code>实现<code>foldl</code>亦同理。</p>
<p>以<code>foldl</code>实现<code>foldr</code>为例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    foldr f z xs = foldl (\g x -&gt; \z -&gt; g (f x z)) id xs z</div><div class="line">    foldr (:) [] [1..5] = </div><div class="line">    foldl (\g x -&gt; \z -&gt; g ((:) x z)) id                                         [1..5] []</div><div class="line">&lt;=&gt; foldl (\g x -&gt; \z -&gt; g ((:) x z)) (\z -&gt; id (1 : z))                         [2..5] []</div><div class="line">&lt;=&gt; foldl (\g x -&gt; \z -&gt; g ((:) x z)) (\z -&gt; id (1 : (2 : z)))                   [3..5] []</div><div class="line">&lt;=&gt; foldl (\g x -&gt; \z -&gt; g ((:) x z)) (\z -&gt; id (1 : (2 : (3 : z))))             [4..5] []</div><div class="line">&lt;=&gt; foldl (\g x -&gt; \z -&gt; g ((:) x z)) (\z -&gt; id (1 : (2 : (3 : (4 : z)))))       [5]    []</div><div class="line">&lt;=&gt; foldl (\g x -&gt; \z -&gt; g ((:) x z)) (\z -&gt; id (1 : (2 : (3 : (4 : (5 : z)))))) []     []</div><div class="line">&lt;=&gt; (\z -&gt; id (1 : (2 : (3 : (4 : (5 : z)))))) []</div><div class="line">&lt;=&gt; id (1 : (2 : (3 : (4 : (5 : [])))))</div><div class="line">&lt;=&gt; [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure></p>
<p>以上应该能够为你建立起一些intuition了，不过对于我来说其实还不够，更重要的是建立起对<code>fold</code>的求值结果是一个函数的直观感受。</p>
<hr>
<h1 id="重新审视"><a href="#重新审视" class="headerlink" title="重新审视"></a>重新审视</h1><h2 id="fold-right-to-fold-left"><a href="#fold-right-to-fold-left" class="headerlink" title="fold right to fold left"></a>fold right to fold left</h2><p>现在重新看<code>foldl</code>的正常递归实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">foldl</span> :: <span class="type">Foldable</span> t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</div><div class="line"><span class="title">foldl</span> f z [] = z</div><div class="line"><span class="title">foldl</span> f z (x:xs) = foldl f (f z x) xs</div></pre></td></tr></table></figure></p>
<p>换一种等价写法（关键）<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">foldl</span> f z xs = g xs z</div><div class="line">  <span class="keyword">where</span> g []     z = z</div><div class="line">        g (x:xs) z = g xs (f z x)</div></pre></td></tr></table></figure></p>
<p>再进一步<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">foldl</span> f z xs = g xs z</div><div class="line">  <span class="keyword">where</span> g []     = \z -&gt; z = id</div><div class="line">        g (x:xs) = \z -&gt; g xs (f z x)</div></pre></td></tr></table></figure></p>
<p>假设我们有这样一个<code>cons</code>实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">cons</span> :: [a] -&gt; [a]</div><div class="line"><span class="title">cons</span> []     = []</div><div class="line"><span class="title">cons</span> (x:xs) = x : (cons xs)</div></pre></td></tr></table></figure></p>
<p><code>cons</code>用<code>foldr</code>实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">cons</span> = foldr (\x r -&gt; x : r) []</div><div class="line">// 其中r替换原来的cons xs</div></pre></td></tr></table></figure></p>
<p>经过对比，<code>g</code>一样可以用<code>foldr</code>实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">g</span> = foldr (\x r -&gt; \z -&gt; r (f z x)) id</div><div class="line">// 其中r替换原来的g xs</div></pre></td></tr></table></figure></p>
<p>因此，将<code>g</code>代入<code>foldl f z xs = g xs z</code>，得到：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">foldl</span> f z xs = foldr (\x r -&gt; \z -&gt; r (f z x)) id xs z</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读本文请自备纸、笔、头痛药。&lt;/p&gt;
    
    </summary>
    
      <category term="函数式编程" scheme="http://gaufoo.com/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Haskell" scheme="http://gaufoo.com/tags/Haskell/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用Haskell构建Parser Combinator（二）</title>
    <link href="http://gaufoo.com/parser2/"/>
    <id>http://gaufoo.com/parser2/</id>
    <published>2018-03-18T02:16:34.000Z</published>
    <updated>2018-03-18T05:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>上期链接：<a href="http://gaufoo.com/2018/03/10/parser/">用Haskell构建Parser Combinator（一）</a></p>
<a id="more"></a>
<hr>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>上篇文章从<code>Parser</code>的类型、<code>Parser</code>的最简实现，一步步讲到<code>Parser</code>的<code>Monad</code>和相对完整的<code>Parser</code>库。<br>实际上，该<code>Parser</code>已经可以完成大部分的解析工作了。然而，当解析错误时，此<code>Parser</code>仅仅简单地返回<code>Nothing</code>。<br>当我们需要更为丰富的错误信息时，则需要在原来<code>Parser</code>的基础上，增加相应的模块。</p>
<hr>
<h1 id="类型修改"><a href="#类型修改" class="headerlink" title="类型修改"></a>类型修改</h1><p>还记得（一）中，<code>Parser</code>类型是：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Parser</span> a = <span class="type">Parser</span> (<span class="type">String</span> -&gt; <span class="type">Maybe</span> (<span class="title">a</span>, <span class="type">String</span>))</span></div></pre></td></tr></table></figure></p>
<p>既然需要错误信息，就不能简单地返回<code>Nothing</code>，而应该是一个<code>String</code>。因此需要把类型改成<code>Either</code>/<code>Except</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Parser</span> a = <span class="type">Parser</span> (<span class="type">String</span> -&gt; <span class="type">Either</span> <span class="type">String</span> (<span class="title">a</span>, <span class="type">String</span>))</span></div></pre></td></tr></table></figure></p>
<h2 id="添加错误信息"><a href="#添加错误信息" class="headerlink" title="添加错误信息"></a>添加错误信息</h2><h3 id="satisfy"><a href="#satisfy" class="headerlink" title="satisfy"></a>satisfy</h3><p>在<code>satisfy</code>实现中添加错误信息：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">satisfy</span> :: (<span class="type">Char</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">satisfy</span> prd = <span class="type">Parser</span> $ \<span class="keyword">case</span></div><div class="line">    <span class="string">""</span> -&gt; <span class="type">Left</span> <span class="string">"End of input"</span></div><div class="line">    (x:xs) -&gt; <span class="keyword">if</span> prd x </div><div class="line">                <span class="keyword">then</span> <span class="type">Right</span> (x, xs) </div><div class="line">                <span class="keyword">else</span> <span class="type">Left</span> $ <span class="string">"unexcepted: "</span> ++ show x</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (char 'a') <span class="string">"a"</span></div><div class="line"><span class="type">Right</span> ('a',<span class="string">""</span>)</div><div class="line">λ&gt; runParse (char 'a') <span class="string">"b"</span></div><div class="line"><span class="type">Left</span> <span class="string">"unexcepted: 'b'"</span></div><div class="line">λ&gt; runParse (char 'a') <span class="string">""</span></div><div class="line"><span class="type">Left</span> <span class="string">"End of input"</span></div></pre></td></tr></table></figure></p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>把这些<code>instance</code>改一下，就完成了程序的修改。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  fmap f pa = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">      <span class="type">Right</span> (x, rest) -&gt; <span class="type">Right</span> (f x, rest)</div><div class="line">      <span class="type">Left</span> x -&gt; <span class="type">Left</span> x</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  pure x = <span class="type">Parser</span> $ \inp -&gt; <span class="type">Right</span> (x, inp)</div><div class="line">  pab &lt;*&gt; pa = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pab inp <span class="keyword">of</span></div><div class="line">      <span class="type">Right</span> (fab, rest) -&gt; runParse (fmap fab pa) rest</div><div class="line">      <span class="type">Left</span> x -&gt; <span class="type">Left</span> x</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  pa &gt;&gt;= apb = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">      <span class="type">Right</span> (a, rest) -&gt; runParse (apb a) rest</div><div class="line">      <span class="type">Left</span> x -&gt; <span class="type">Left</span> x</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  empty = <span class="type">Parser</span> $ const (<span class="type">Left</span> <span class="string">""</span>)</div><div class="line">  pa &lt;|&gt; pb = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">      <span class="type">Left</span> _ -&gt; runParse pb inp</div><div class="line">      x -&gt; x</div></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse nature <span class="string">"123"</span></div><div class="line"><span class="type">Right</span> (<span class="number">123</span>,<span class="string">""</span>)</div><div class="line">λ&gt; runParse nature <span class="string">"adc"</span></div><div class="line"><span class="type">Left</span> <span class="string">"unexcepted: 'a'"</span></div></pre></td></tr></table></figure></p>
<hr>
<h1 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h1><p>以上的“错误信息”虽聊胜于无，但是我们不应该就此满足。一份能用的错误信息，应该是具体的、有效的、能给用户以适当指示的。<br>因此，最好能够加上位置信息，以及能够自由地给出和修改提示。<br>接下来，让我们进一步修改类型。</p>
<h2 id="位置信息"><a href="#位置信息" class="headerlink" title="位置信息"></a>位置信息</h2><p>平时我们使用编译器、解释器，代码中存在语法错误时，编译器、解释器的<code>Parser</code>总能正确地指出错误所在位置，使我们不必迷失在代码的海洋中不知所措（C++ template metaprogramming除外）。</p>
<p>考虑到添加位置信息的需求，那就需要考虑位置信息的存在、更新方式。我们这里的做法是，把位置信息与待解析字符串捆绑在一起，形成<code>PString</code>，消耗字符串的时候，位置信息同步更新。<br><code>PString</code>类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Pos</span> = <span class="type">Pos</span> (<span class="type">Int</span>, <span class="type">Int</span>)</span></div><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">PString</span> = <span class="type">PString</span> (<span class="type">Pos</span>, <span class="type">String</span>)</span></div></pre></td></tr></table></figure></p>
<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>有了位置信息，接下来我们就可以修改错误信息了。原本错误信息类型是简单的<code>String</code>，现在使用自定义的错误信息类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">ParseError</span> = <span class="type">DefaultError</span> <span class="type">String</span></span></div><div class="line">                | <span class="type">EndOfInput</span> <span class="type">Pos</span></div><div class="line">                | <span class="type">Chatty</span> <span class="type">String</span> <span class="type">Pos</span></div></pre></td></tr></table></figure></p>
<ul>
<li><code>DefaultError</code>和原来的差不多，仅仅封装了<code>String</code>。</li>
<li><code>EndOfInput</code>只需要装上位置信息。</li>
<li><code>Chatty</code>同时需要位置信息和错误信息，以便于精确控制错误信息。</li>
</ul>
<h2 id="重造Parser类型"><a href="#重造Parser类型" class="headerlink" title="重造Parser类型"></a>重造Parser类型</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Control.Monad</div><div class="line"><span class="keyword">import</span> Control.Monad.Except</div><div class="line"><span class="keyword">import</span> Control.Monad.State</div><div class="line"><span class="keyword">import</span> Control.Applicative</div><div class="line"></div><div class="line">...</div><div class="line">...</div><div class="line">...</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Parser</span> a = <span class="type">Parser</span></span></div><div class="line">  &#123; runP :: <span class="type">ExceptT</span> <span class="type">ParseError</span> (<span class="type">State</span> <span class="type">PString</span>) a &#125;</div><div class="line">  <span class="keyword">deriving</span> (<span class="type">Functor</span>, <span class="type">Applicative</span>, <span class="type">Monad</span>, <span class="type">MonadError</span> <span class="type">ParseError</span>)</div></pre></td></tr></table></figure>
<p>以上便是最终的<code>Parser</code>类型。<br>用上了<code>Monad Transformer</code>，有以下好处：</p>
<ul>
<li>便于结合多种<code>Monad</code>。</li>
<li>让编译器自动实现各种范畴。仅仅需要在文件头加上：<code>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</code></li>
</ul>
<p>此时，由于使用了<code>ExceptT</code>，通过<code>throwError</code>和<code>catchError</code>，我们就可以非常方便地添加和修改错误信息。</p>
<hr>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><p>还记得上篇文章中提到，<code>&lt;|&gt;</code>的实现是强制回溯的。现在有了<code>catchError</code>，我们可以实现不回溯的<code>&lt;|&gt;</code>版本。当需要回溯时，可以使用<code>try</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  empty = throwError (<span class="type">DefaultError</span> <span class="string">""</span>)</div><div class="line">  p1 &lt;|&gt; p2 = p1 `catchError` const p2</div></pre></td></tr></table></figure>
<p>直接<code>catch</code> <code>p1</code>的失败，这时<code>PString</code>已经消耗，若此时再让<code>p2</code>去解析，回溯就不会发生。</p>
<p><br><br><code>try</code>的实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">try</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">try</span> p = <span class="keyword">do</span></div><div class="line">  <span class="type">PString</span> s &lt;- <span class="type">Parser</span> $ lift get</div><div class="line">  p `catchError` \e -&gt; <span class="type">Parser</span> $ lift (put $ <span class="type">PString</span> s) &gt;&gt; throwError e</div></pre></td></tr></table></figure></p>
<p><code>get</code>把<code>PString</code>拿到，如果<code>p</code>解析失败了，就把原来的<code>PString</code>放回去然后抛出错误，从而实现了回溯。</p>
<hr>
<h2 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h2><p>待解析字符串和位置信息要同时更新，因此我们要重新实现<code>satisfy</code>，以满足需求：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="title">satisfy</span> :: (<span class="type">Char</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">satisfy</span> prd = <span class="keyword">do</span></div><div class="line">  <span class="type">PString</span> s &lt;- <span class="type">Parser</span> $ lift get</div><div class="line">  <span class="keyword">case</span> s <span class="keyword">of</span></div><div class="line">    (p, <span class="string">""</span>) -&gt; throwError $ <span class="type">EndOfInput</span> p</div><div class="line">    (p@(<span class="type">Pos</span> (r, c)), x : xs) -&gt; <span class="keyword">if</span> prd x</div><div class="line">                                <span class="keyword">then</span> <span class="keyword">let</span> newPos = <span class="keyword">case</span> x <span class="keyword">of</span></div><div class="line">                                                    '\n' -&gt; <span class="type">Pos</span> (r + <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">                                                    '\t' -&gt; <span class="type">Pos</span> (r, c + <span class="number">8</span>)</div><div class="line">                                                    _    -&gt; <span class="type">Pos</span> (r, c + <span class="number">1</span>)</div><div class="line">                                     <span class="keyword">in</span> <span class="type">Parser</span> $ lift (put $ <span class="type">PString</span> (newPos, xs)) &gt;&gt; return x</div><div class="line">                                <span class="keyword">else</span> throwError $ <span class="type">Chatty</span> (<span class="string">"unexcepted char: "</span> ++ show x) p</div></pre></td></tr></table></figure></p>
<p>注意到<code>&#39;\n&#39;</code>, <code>&#39;\t&#39;</code>以及其他字符的区别。</p>
<hr>
<h2 id="runParser与错误信息输出"><a href="#runParser与错误信息输出" class="headerlink" title="runParser与错误信息输出"></a>runParser与错误信息输出</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="title">runParser</span> :: <span class="type">Parser</span> a -&gt; <span class="type">String</span> -&gt; <span class="type">Either</span> <span class="type">ParseError</span> a</div><div class="line"><span class="title">runParser</span> p str =</div><div class="line">  <span class="keyword">case</span> (runState . runExceptT . runP) p (<span class="type">PString</span> (<span class="type">Pos</span> (<span class="number">1</span>, <span class="number">1</span>), str)) <span class="keyword">of</span></div><div class="line">    (<span class="type">Left</span> err, _) -&gt; <span class="type">Left</span> (<span class="type">DefaultError</span> $ <span class="string">"&lt;interactive&gt;:"</span> ++ showErr err str)</div><div class="line">    (<span class="type">Right</span> r, _) -&gt; <span class="type">Right</span> r</div><div class="line"></div><div class="line"><span class="title">showErr</span> :: <span class="type">ParseError</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></div><div class="line"><span class="title">showErr</span> x input = <span class="keyword">case</span> x <span class="keyword">of</span></div><div class="line">    <span class="type">EndOfInput</span> (<span class="type">Pos</span> (r, c)) -&gt; show r ++ <span class="string">":"</span> ++ show c</div><div class="line">                               ++ <span class="string">": error: end of input\n&lt;EOF&gt;\n^"</span></div><div class="line">    <span class="type">Chatty</span> msg (<span class="type">Pos</span> (r, c)) -&gt; show r ++ <span class="string">":"</span> ++ show c</div><div class="line">                               ++ <span class="string">": error: "</span> ++ msg ++ <span class="string">"\n"</span></div><div class="line">                               ++ (lines input !! (r - <span class="number">1</span>)) ++ <span class="string">"&lt;EOF&gt;\n"</span></div><div class="line">                               ++ replicate (c - <span class="number">1</span>) ' ' ++ <span class="string">"^"</span> </div><div class="line">    <span class="type">DefaultError</span> s -&gt; s</div></pre></td></tr></table></figure>
<p>注意到<code>runParser</code>中，待解析字符串和位置<code>(1, 1)</code>结合。<br><code>showErr</code>中，<code>Chatty</code>和<code>EndOfInput</code>错误都有对应的<code>Pretty Print</code>。</p>
<p>把这些都封装在<code>parse</code>函数中，转换成<code>IO ()</code>类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">parse</span> :: <span class="type">Show</span> a =&gt; <span class="type">Parser</span> a -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</div><div class="line"><span class="title">parse</span> p str =</div><div class="line">  <span class="keyword">case</span> runParser p str <span class="keyword">of</span></div><div class="line">    <span class="type">Left</span> (<span class="type">DefaultError</span> x) -&gt; putStrLn $ <span class="string">"Failure: "</span> ++ x</div><div class="line">    <span class="type">Right</span> r -&gt; putStrLn $ <span class="string">"Success: "</span> ++ show r</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="添加错误信息-1"><a href="#添加错误信息-1" class="headerlink" title="添加错误信息"></a>添加错误信息</h1><p>由于<code>ExceptT</code>带有<code>catchError</code>，可以利用它来提供更丰富的错误信息。</p>
<p>首先实现通用的<code>catchChattyError</code>，它的作用是<code>catch</code>到<code>ChattyError</code>，添加上我们指定的额外错误信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">catchChattyError</span> :: <span class="type">Parser</span> a -&gt; <span class="type">String</span> -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">catchChattyError</span> p msg = p </div><div class="line">  `catchError` </div><div class="line">    \<span class="keyword">case</span></div><div class="line">      <span class="type">Chatty</span> m pos -&gt; throwError $ <span class="type">Chatty</span> (m ++ <span class="string">", "</span> ++ msg) pos</div><div class="line">      otherError -&gt; throwError otherError</div></pre></td></tr></table></figure></p>
<p>接着恰当修改之前实现过的所有<code>Parser</code>，在末尾加上更有用的信息：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="title">char</span> :: <span class="type">Char</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">char</span> x = satisfy (==x) `catchChattyError` (<span class="string">"excepted char: "</span> ++ show x)</div><div class="line"></div><div class="line"><span class="title">space</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">space</span> = satisfy isSpace `catchChattyError` <span class="string">"excepted a white space character"</span></div><div class="line"></div><div class="line"><span class="title">upper</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">upper</span> = satisfy isUpper `catchChattyError` <span class="string">"excepted an upper letter"</span></div><div class="line"></div><div class="line"><span class="title">lower</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">lower</span> = satisfy isLower `catchChattyError` <span class="string">"excepted a lower letter"</span></div><div class="line"></div><div class="line"><span class="title">alphaNum</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">alphaNum</span> = satisfy isAlphaNum `catchChattyError` <span class="string">"excepted a letter or digit"</span></div><div class="line"></div><div class="line"><span class="title">letter</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">letter</span> = satisfy isAlpha `catchChattyError` <span class="string">"excepted a letter"</span></div><div class="line"></div><div class="line"><span class="title">digit</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">digit</span> = satisfy isDigit `catchChattyError` <span class="string">"excepted a digit"</span></div><div class="line"></div><div class="line"><span class="title">hexDigit</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">hexDigit</span> = satisfy isHexDigit `catchChattyError` <span class="string">"excepted a hexadecimal digit"</span></div><div class="line"></div><div class="line"><span class="title">octDigit</span> :: <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">octDigit</span> = satisfy isOctDigit `catchChattyError` <span class="string">"excepted a octal digit"</span></div><div class="line"></div><div class="line"><span class="title">oneOf</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">oneOf</span> cs = satisfy (`elem` cs) `catchChattyError` (<span class="string">"excepted one char of ["</span> ++ cs ++ <span class="string">"]"</span>)</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">λ&gt; parse (string <span class="string">"123"</span>) <span class="string">"124"</span></div><div class="line"><span class="type">Failure</span>: &lt;interactive&gt;:<span class="number">1</span>:<span class="number">3</span>: error: unexcepted char: '<span class="number">4</span>', excepted char: '<span class="number">3</span>'</div><div class="line"><span class="number">124</span>&lt;<span class="type">EOF</span>&gt;</div><div class="line">  ^</div><div class="line">λ&gt; parse (string <span class="string">"123"</span>) <span class="string">""</span></div><div class="line"><span class="type">Failure</span>: &lt;interactive&gt;:<span class="number">1</span>:<span class="number">1</span>: error: end <span class="keyword">of</span> input</div><div class="line">&lt;<span class="type">EOF</span>&gt;</div><div class="line">^</div><div class="line">λ&gt; parse (oneOf <span class="string">"123"</span>) <span class="string">"abcde"</span></div><div class="line"><span class="type">Failure</span>: &lt;interactive&gt;:<span class="number">1</span>:<span class="number">1</span>: error: unexcepted char: 'a', excepted one char <span class="keyword">of</span> [<span class="number">123</span>]</div><div class="line"><span class="title">abcde</span>&lt;<span class="type">EOF</span>&gt;</div><div class="line">^</div><div class="line">λ&gt; parse (some (oneOf <span class="string">"123"</span>)) <span class="string">"123321"</span></div><div class="line"><span class="type">Success</span>: <span class="string">"123321"</span></div></pre></td></tr></table></figure></p>
<p>达成任务。</p>
<hr>
<h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h1><ul>
<li>现实例子，比如解析<code>JSON</code>类型。</li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上期链接：&lt;a href=&quot;http://gaufoo.com/2018/03/10/parser/&quot;&gt;用Haskell构建Parser Combinator（一）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Haskell" scheme="http://gaufoo.com/tags/Haskell/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Continuation与Call/CC</title>
    <link href="http://gaufoo.com/continuation/"/>
    <id>http://gaufoo.com/continuation/</id>
    <published>2018-03-12T01:50:13.000Z</published>
    <updated>2018-03-12T09:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>和我同乘时光机。</p>
<a id="more"></a>
<hr>
<h1 id="本文要点"><a href="#本文要点" class="headerlink" title="本文要点"></a>本文要点</h1><h2 id="你将收获"><a href="#你将收获" class="headerlink" title="你将收获"></a>你将收获</h2><ul>
<li>了解<code>Continuation</code>的概念。</li>
<li>了解<code>CPS</code>(<code>Continuation Passing Style</code>)的概念与优势。</li>
<li>有机会搭乘<code>Call With Current Continuation</code>这台时光机。</li>
</ul>
<h2 id="所需基础"><a href="#所需基础" class="headerlink" title="所需基础"></a>所需基础</h2><ul>
<li>熟悉Haskell的Monad用法。</li>
</ul>
<hr>
<h1 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h1><h2 id="什么是Continuation"><a href="#什么是Continuation" class="headerlink" title="什么是Continuation"></a>什么是Continuation</h2><p>为了了解何谓<code>Continuation</code>，我们先来考虑这样一个表达式：<code>4 * 3</code><br>如果把焦点放在<code>3</code>上，在这里给出两种求值风格：</p>
<ul>
<li><code>(4*) 3</code></li>
<li><code>($3) (4*)</code></li>
</ul>
<p>它们的结果都是一样的：<code>12</code>。<br>前者，<code>3</code>被函数<code>(4*)</code>调用。后者，<code>3</code>选择让<code>(4*)</code>调用自己。<br>这期间微妙的区别，便是CPS(<code>Continuation Passing Style</code>)的来由。后者是典型的CPS，<code>(4*)</code>就是<code>3</code>的<code>Continuation</code>。</p>
<p>从<code>CPS</code>的角度看，<code>($3)</code>要做的事情就是等待。它的类型是：<code>(a -&gt; r) -&gt; r</code>，意味着，它需要一个函数作为参数，才能求出最后的结果。它所等待的函数，类型为<code>a -&gt; r</code>，被称为<code>Continuation</code>，<code>Continuation</code>指定了最终值应该如何被求得。</p>
<p>在实践中，我们可以简单地通过<code>flip ($)</code>，将一个值转换成等待应用的形式。另外，可以通过传递<code>id</code>函数作为其参数，把原始值返回。</p>
<hr>
<h2 id="Continuation的好处"><a href="#Continuation的好处" class="headerlink" title="Continuation的好处"></a>Continuation的好处</h2><p><code>Continuation</code>的内涵可不仅仅是这样简单地调换应用顺序，更重要的是，它带给了我们显式操控和动态选择程序控制流的可能。比如，实现程序的提前返回，异常的传递和处理可以通过<code>Continuation</code>实现 —— 一个<code>Continuation</code>用于处理正常情况，另一个<code>Continuation</code>用于处理异常情况，以及实现简单的并发(<code>Concurrency</code>)。</p>
<p>而且，当我们所有的函数都严格按照<code>CPS</code>来编写，那么所有的函数调用都会是尾调用(<code>Tail Call</code>)的形式。使用尾调用形式可以进行尾调用优化(<code>TCO</code>, <code>Tail Call Optimization</code>)，使得程序不再需要运行时栈(<code>Run-time Stack</code>)，在现在的许多解释器和编译器中，都能找到这样一种技术。</p>
<hr>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>想要采用<code>Continuation</code>的简单方法是修改所有函数，让函数返回待应用的形式。下面将演示两个实例。</p>
<h3 id="pythagoras"><a href="#pythagoras" class="headerlink" title="pythagoras"></a>pythagoras</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 普通函数调用风格，计算平方和:</span></div><div class="line"></div><div class="line"><span class="title">add</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">add</span> x y = x + y</div><div class="line"></div><div class="line"><span class="title">square</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">square</span> x = x * x</div><div class="line"></div><div class="line"><span class="title">pythagoras</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">pythagoras</span> x y = add (square x) (square y)</div></pre></td></tr></table></figure>
<p>将返回值修改成待应用形式，<code>pythagoras</code>将变成：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 函数的CPS版本</span></div><div class="line"></div><div class="line"><span class="title">add_cps</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; ((<span class="type">Int</span> -&gt; r) -&gt; r)</div><div class="line"><span class="title">add_cps</span> x y = \k -&gt; k (add x y)</div><div class="line"></div><div class="line"><span class="title">square_cps</span> :: <span class="type">Int</span> -&gt; ((<span class="type">Int</span> -&gt; r) -&gt; r)</div><div class="line"><span class="title">square_cps</span> x = \k -&gt; k (square x)</div><div class="line"></div><div class="line"><span class="title">pythagoras_cps</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; ((<span class="type">Int</span> -&gt; r) -&gt; r)</div><div class="line"><span class="title">pythagoras_cps</span> x y = \k -&gt;</div><div class="line"> square_cps x $ \x_squared -&gt;</div><div class="line"> square_cps y $ \y_squared -&gt;</div><div class="line"> add_cps x_squared y_squared $ k</div></pre></td></tr></table></figure>
<p><code>pythagoras_cps</code>执行过程：</p>
<ul>
<li>把<code>x</code>求平方，把结果丢到<code>\x_squared -&gt; ...</code>这个<code>Continuation</code>里。</li>
<li>把<code>y</code>求平方，把结果丢到<code>\y_squared -&gt; ...</code>这个<code>Continuation</code>里。</li>
<li>把<code>x_squared</code>和<code>y_squared</code>加起来，把结果丢到<code>k</code>这个<code>Continuation</code>里。</li>
</ul>
<p>在GHCi里运行一下，把<code>id</code>作为参数/<code>Continuation</code>传给最终程序：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; pythagoras_cps <span class="number">3</span> <span class="number">4</span> id</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure></p>
<p>从这里我们已经可以看出，<code>CPS</code>这种风格最突出的特征是：所有函数调用都要把未来需要做的事情显式地传递给它。函数不止关注自己的值如何求出，还关注求出的值如何被使用。</p>
<h3 id="thrice"><a href="#thrice" class="headerlink" title="thrice"></a>thrice</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 一个高阶函数，无Continuation版本</span></div><div class="line"></div><div class="line"><span class="title">thrice</span> :: (a -&gt; a) -&gt; a -&gt; a</div><div class="line"><span class="title">thrice</span> f x = f (f (f x))</div></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; thrice tail <span class="string">"foobar"</span></div><div class="line"><span class="string">"bar"</span></div></pre></td></tr></table></figure>
<p>像<code>thrice</code>这样的高阶函数，转换成<code>CPS</code>时，它接受的函数参数也要改成相应的<code>CPS</code>版本。因此<code>f :: a -&gt; a</code>将变成<code>f_cps :: a -&gt; ((a -&gt; r) -&gt; r)</code>，最终类型变成<code>thrice_cps :: (a -&gt; ((a -&gt; r) -&gt; r)) -&gt; a -&gt; ((a -&gt; r) -&gt; r)</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 高阶函数带Continuation版本</span></div><div class="line"></div><div class="line"><span class="title">thrice_cps</span> :: (a -&gt; ((a -&gt; r) -&gt; r)) -&gt; a -&gt; ((a -&gt; r) -&gt; r)</div><div class="line"><span class="title">thrice_cps</span> f_cps x = \k -&gt;</div><div class="line"> f_cps x $ \fx -&gt;</div><div class="line"> f_cps fx $ \ffx -&gt;</div><div class="line"> f_cps ffx $ k</div></pre></td></tr></table></figure>
<hr>
<h1 id="Cont-Monad"><a href="#Cont-Monad" class="headerlink" title="Cont Monad"></a>Cont Monad</h1><p>有了这些<code>continuation-passing</code>函数，下一步应该做的是提供一种更简洁的组合它们的方法，而不是像上面那样嵌套那么多<code>lambda</code>。<br>先来尝试写出用于应用(<code>apply</code>)待应用函数的组合子(<code>Combinator</code>)。它的类型应该是这样的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">chainCPS</span> :: ((a -&gt; r) -&gt; r) -&gt; (a -&gt; ((b -&gt; r) -&gt; r)) -&gt; ((b -&gt; r) -&gt; r)</div></pre></td></tr></table></figure></p>
<p>实现如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">chainCPS</span> s f = \k -&gt; s $ \x -&gt; f x $ k</div></pre></td></tr></table></figure></p>
<p>调用者首先提供一个待应用形式的值<code>s</code>，通过嵌套的<code>lambda</code>把<code>a</code>类型的值拿到，让<code>f</code>应用于它，最后再用新的<code>Continuation</code>即<code>k</code>把这一切包裹起来。</p>
<p>没错，相信聪明的读者已经看出来，上面的函数类型和<code>Monad</code>里的<code>(&gt;&gt;=)</code>函数类型相当相似。而且，<code>flip ($)</code>也可以充当<code>return</code>的角色。</p>
<p><br><br><strong>一个新的<code>Monad</code>诞生了。</strong><br><br></p>
<p>我们可以定义<code>Cont r a</code>来包裹这种待应用形式的值，再实现包装和解包函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">cont</span> :: ((a -&gt; r) -&gt; r) -&gt; <span class="type">Cont</span> r a</div><div class="line"><span class="title">runCont</span> :: <span class="type">Cont</span> r a -&gt; (a -&gt; r) -&gt; r</div></pre></td></tr></table></figure></p>
<p><code>Monad</code>的实现上面已经介绍过，不同的只是包装和解包：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> (<span class="type">Cont</span> <span class="title">r</span>) <span class="keyword">where</span></span></div><div class="line">    return x = cont ($ x)</div><div class="line">    s &gt;&gt;= f  = cont $ \c -&gt; runCont s $ \x -&gt; runCont (f x) c</div></pre></td></tr></table></figure></p>
<p><code>Monad</code>实例把<code>Continuation</code>的传递隐藏起来，拥有了<code>Monad</code>绑定的种种好处，把上面的<code>pythagoras</code>重写一下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 使用transformers包里面的Cont Monad</span></div><div class="line"><span class="keyword">import</span> Control.Monad.Trans.Cont</div><div class="line"></div><div class="line"><span class="title">add_cont</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">add_cont</span> x y = return (add x y)</div><div class="line"></div><div class="line"><span class="title">square_cont</span> :: <span class="type">Int</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">square_cont</span> x = return (square x)</div><div class="line"></div><div class="line"><span class="title">pythagoras_cont</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">pythagoras_cont</span> x y = <span class="keyword">do</span></div><div class="line">    x_squared &lt;- square_cont x</div><div class="line">    y_squared &lt;- square_cont y</div><div class="line">    add_cont x_squared y_squared</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="callCC"><a href="#callCC" class="headerlink" title="callCC"></a>callCC</h1><p>实现了可爱的<code>Monad</code>固然是值得高兴的，可是别忘了我们想要<code>CPS</code>的目的：用<code>Continuation</code>精确操控程序控制流。如果把<code>Continuation</code>都隐藏在<code>Monad</code>背后，这种控制将不复存在。为了纠正这个问题，我们引入了<code>callCC</code>函数。</p>
<p><code>callCC</code>是一个非常神奇的函数，举个例子：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- Without callCC</span></div><div class="line"><span class="title">square</span> :: <span class="type">Int</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">square</span> n = return (n ^ <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">-- With callCC</span></div><div class="line"><span class="title">squareCCC</span> :: <span class="type">Int</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">squareCCC</span> n = callCC $ \k -&gt; k (n ^ <span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<p>传递给<code>callCC</code>的是一个函数，这个函数的返回值是一个待应用形式的值(即类型为<code>Cont r a</code>)。重点来了：让<code>callCC</code>如此特殊的原因就在于<code>k</code>，是<code>k</code>让精确控制程序成为可能。</p>
<p><strong>那么<code>k</code>究竟是何方神圣？</strong></p>
<p>事情是这样的：<br>程序调用<code>callCC</code>的瞬间，在此处就放置了一个<code>传送门</code>、或者说<code>存档点</code>、或者说<code>时光机</code>。业界所说的放置了<code>坑</code>，我认为不甚准确。<code>k</code>就是这个<code>传送门</code>在<code>callCC</code>内部的另一端。一旦内部有任何一个值调用了<code>k</code>，<code>k</code>就会无条件地把这个值传递回去，内部此后任何对<code>k</code>的调用都将被无情抛弃。<br>从另一个角度来看，<code>k</code>也可以说是调用<code>callCC</code>以后的所有计算，一旦<code>callCC</code>内部有值调用了<code>k</code>，<code>k</code>就将外面的整个世界传递给这个值，毕竟<code>callCC</code>的全称是<code>call with current continuation</code>。<br>随读者怎么理解，我更倾向于前者。</p>
<p>下面我们就来探索<code>callCC</code>究竟可以有怎样的可能性。</p>
<hr>
<h2 id="决定何时使用k"><a href="#决定何时使用k" class="headerlink" title="决定何时使用k"></a>决定何时使用k</h2><p><code>callCC</code>允许我们决定让什么值传递回去，以及何时传递。下面举个例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 简单的callCC调用</span></div><div class="line"></div><div class="line"><span class="title">foo</span> :: <span class="type">Int</span> -&gt; <span class="type">Cont</span> r <span class="type">String</span></div><div class="line"><span class="title">foo</span> x = callCC $ \k -&gt; <span class="keyword">do</span></div><div class="line">    <span class="keyword">let</span> y = x ^ <span class="number">2</span> + <span class="number">3</span></div><div class="line">    when (y &gt; <span class="number">20</span>) $ k <span class="string">"over twenty"</span></div><div class="line">    return (show $ y - <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>如果<code>y</code>的值大于<code>20</code>，<code>k</code>就会带着<code>&quot;over twenty&quot;</code>回到<code>Continuation</code>，否则，直到最终才让<code>show $ y - 4</code>返回到<code>Continuation</code>中。<br>从这里看，<code>k</code>有点像命令式语言里的<code>return</code>，但实际上<code>k</code>远远强大于<code>return</code>，因为它是头等公民，你可以把<code>k</code>传递给其他函数，比如<code>when</code>，把<code>k</code>存储在<code>Reader</code>里等等。</p>
<p>同样，你可以在<code>do</code>里面嵌入<code>callCC</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">bar</span> :: <span class="type">Char</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">bar</span> c s = <span class="keyword">do</span></div><div class="line">    msg &lt;- callCC $ \k -&gt; <span class="keyword">do</span></div><div class="line">        <span class="keyword">let</span> s0 = c : s</div><div class="line">        when (s0 == <span class="string">"hello"</span>) $ k <span class="string">"They say hello."</span></div><div class="line">        <span class="keyword">let</span> s1 = show s0</div><div class="line">        return (<span class="string">"They appear to be saying "</span> ++ s1)</div><div class="line">    return (length msg)</div></pre></td></tr></table></figure>
<p>从这里看，<code>k</code>又有点像其他语言里的<code>goto</code>，调用了<code>k</code>就会返回到<code>msg &lt;- ...</code>这一行。</p>
<p><code>k</code>后面的无用的行：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">quux</span> :: <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">quux</span> = callCC $ \k -&gt; <span class="keyword">do</span></div><div class="line">    <span class="keyword">let</span> n = <span class="number">5</span></div><div class="line">    k n</div><div class="line">    return <span class="number">25</span></div></pre></td></tr></table></figure></p>
<p>这个函数会把<code>5</code>返回到<code>Continuation</code>中，<code>return 25</code>是完完全全没有作用的。</p>
<hr>
<h2 id="舞台背后"><a href="#舞台背后" class="headerlink" title="舞台背后"></a>舞台背后</h2><p>如此神奇的<code>callCC</code>究竟如何实现。经过上面的举例，我们可以得出<code>callCC</code>的类型为：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">callCC</span> :: ((a -&gt; <span class="type">Cont</span> r b) -&gt; <span class="type">Cont</span> r a) -&gt; <span class="type">Cont</span> r a</div></pre></td></tr></table></figure></p>
<p>总体返回应该和参数函数的返回类型一致(即<code>Cont r a</code>)，因为在没有调用<code>k</code>的情况下，得出的返回值应该一致。<br>那么<code>k</code>的类型呢？<br>正如上面所演示的，<code>k</code>的参数将被传到<code>calCC</code>调用点处。所以，<code>k</code>的参数类型是<code>a</code>。<br>不过<code>k</code>的返回类型就有点意思了，<code>b</code>代表着任意类型。因为上面提过，<code>k</code>意味着跟在<code>callCC</code>以后的任何<code>Continuation</code>，所以<code>k</code>的返回类型是任意的。</p>
<blockquote>
<p> <strong>注意：</strong><br>    <figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 有错误的代码</span></div><div class="line"></div><div class="line"><span class="title">quux</span> :: <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">quux</span> = callCC $ \k -&gt; <span class="keyword">do</span></div><div class="line">  <span class="keyword">let</span> n = <span class="number">5</span></div><div class="line">  when <span class="type">True</span> $ k n</div><div class="line">  k <span class="number">25</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>由于<code>when</code>，<code>k n</code>的类型已经被约束为<code>Cont r ()</code>，因此后面的<code>k 25</code>与<code>quux</code>的返回类型不符合，应该改成<code>return 25</code>。</p>
<p>实际实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">callCC</span> f = cont $ \h -&gt; runCont (f (\a -&gt; cont $ \_ -&gt; h a)) h</div></pre></td></tr></table></figure></p>
<p>慢慢看，慢慢理解。</p>
<hr>
<h1 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h1><h2 id="复杂控制结构"><a href="#复杂控制结构" class="headerlink" title="复杂控制结构"></a>复杂控制结构</h2><p>让我们来看看更现实的控制流操控的例子。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&#123;- We use the continuation monad to perform "escapes" from code blocks.</span></div><div class="line"><span class="comment">This function implements a complicated control structure to process</span></div><div class="line"><span class="comment">numbers:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Input (n)     Output                    List Shown</span></div><div class="line"><span class="comment">=========     ======                    ==========</span></div><div class="line"><span class="comment">0-9           n                         none</span></div><div class="line"><span class="comment">10-199        number of digits in (n/2) digits of (n/2)</span></div><div class="line"><span class="comment">200-19999     n                         digits of (n/2)</span></div><div class="line"><span class="comment">20000-1999999 (n/2) backwards           none</span></div><div class="line"><span class="comment">&gt;= 2000000    sum of digits of (n/2)    digits of (n/2)</span></div><div class="line"><span class="comment">-&#125;</span> </div><div class="line"><span class="title">fun</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></div><div class="line"><span class="title">fun</span> n = (`runCont` id) $ <span class="keyword">do</span></div><div class="line">    str &lt;- callCC $ \exit1 -&gt; <span class="keyword">do</span>                            <span class="comment">-- define "exit1"</span></div><div class="line">        when (n &lt; <span class="number">10</span>) (exit1 (show n))</div><div class="line">        <span class="keyword">let</span> ns = map digitToInt (show (n `div` <span class="number">2</span>))</div><div class="line">        n' &lt;- callCC $ \exit2 -&gt; <span class="keyword">do</span>                         <span class="comment">-- define "exit2"</span></div><div class="line">            when ((length ns) &lt; <span class="number">3</span>) (exit2 (length ns))</div><div class="line">            when ((length ns) &lt; <span class="number">5</span>) (exit2 n)</div><div class="line">            when ((length ns) &lt; <span class="number">7</span>) $ <span class="keyword">do</span></div><div class="line">                <span class="keyword">let</span> ns' = map intToDigit (reverse ns)</div><div class="line">                exit1 (dropWhile (=='<span class="number">0</span>') ns')               <span class="comment">--escape 2 levels</span></div><div class="line">            return $ sum ns</div><div class="line">        return $ <span class="string">"(ns = "</span> ++ (show ns) ++ <span class="string">") "</span> ++ (show n')</div><div class="line">    return $ <span class="string">"Answer: "</span> ++ str</div></pre></td></tr></table></figure>
<p><code>fun</code>是一个使用<code>Cont</code>和<code>callCC</code>建立起来的控制结构，接受不同的整数值<code>n</code>，而落到不同范围，从而做出不同的事情。剖析一下：</p>
<ol>
<li><code>(`runCont` id)</code>意味着把最终的计算结果<code>Continuation</code>通过<code>id</code>给拿出来。</li>
<li>我们将<code>callCC</code>的结果绑定到<code>str</code>中：<ol>
<li>如果<code>n</code>小于10，直接退出，只显示<code>n</code>。</li>
<li>如果不是，继续进行。构造一个<code>list</code>，叫<code>ns</code>，里面转载<code>n `div` 2</code>的数字字符。</li>
<li>内部<code>callCC</code>，结果绑定到<code>n&#39;</code>：<ol>
<li>如果<code>length ns &lt; 3</code>，带着<code>length ns</code>从内部<code>do-block</code>退出。</li>
<li>如果<code>n `div` 2</code>小于5个字符，带着<code>n</code>从内部<code>do-block</code>退出。</li>
<li>如果<code>n `div` 2</code>小于7个字符，带着一个<code>String</code>直接退出到外部的<code>callCC</code>。</li>
<li>否则，最终带着<code>n `div` 2</code>的<code>sum</code>退出。</li>
</ol>
</li>
<li>最终带着字符串返回。</li>
</ol>
</li>
<li>最终带着<code>str</code>返回。</li>
</ol>
<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><code>Continuation</code>的一种用途是对异常进行建模。要做到这一点，我们要维护两个<code>Continuation</code>，一个带我们到<code>handler</code>处理函数以处理异常，一个在无异常的情况下带我们到处理后的代码。</p>
<p>这里有一个简单的函数，模拟除零异常：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="title">divExcpt</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; (<span class="type">String</span> -&gt; <span class="type">Cont</span> r <span class="type">Int</span>) -&gt; <span class="type">Cont</span> r <span class="type">Int</span></div><div class="line"><span class="title">divExcpt</span> x y handler = callCC $ \ok -&gt; <span class="keyword">do</span></div><div class="line">    err &lt;- callCC $ \notOk -&gt; <span class="keyword">do</span></div><div class="line">        when (y == <span class="number">0</span>) $ notOk <span class="string">"Denominator 0"</span></div><div class="line">        ok $ x `div` y</div><div class="line">    handler err</div><div class="line"></div><div class="line"><span class="comment">&#123;- For example,</span></div><div class="line"><span class="comment">runCont (divExcpt 10 2 error) id --&gt; 5</span></div><div class="line"><span class="comment">runCont (divExcpt 10 0 error) id --&gt; *** Exception: Denominator 0</span></div><div class="line"><span class="comment">-&#125;</span></div></pre></td></tr></table></figure></p>
<p>从代码中可以看出，我们嵌套使用了两个<code>callCC</code>，一个是将在没出问题时使用的<code>Continuation</code>，一个是我们希望抛出异常时将使用到的<code>Continuation</code>。如果分母不是<code>0</code>，则<code>ok</code>的<code>Continuation</code>将直接返回到顶层，否则，<code>err</code>将带着<code>&quot;Denominator 0&quot;</code>交给<code>handler</code>处理。</p>
<p>下面介绍更通用的异常处理方法。第一个参数传递计算方法（准确地说，这个计算会得到一个<code>throw</code>函数，并在定义中决定是否使用）。另一个参数为错误处理程序。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Control.Monad.Cont</div><div class="line"></div><div class="line"><span class="title">tryCont</span> :: <span class="type">MonadCont</span> m =&gt; ((err -&gt; m a) -&gt; m a) -&gt; (err -&gt; m a) -&gt; m a</div><div class="line"><span class="title">tryCont</span> c h = callCC $ \ok -&gt; <span class="keyword">do</span></div><div class="line">    err &lt;- callCC $ \notOk -&gt; <span class="keyword">do</span></div><div class="line">        x &lt;- c notOk</div><div class="line">        ok x</div><div class="line">    h err</div></pre></td></tr></table></figure>
<p>将<code>try</code>用到<code>action</code>中：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">SqrtException</span> = <span class="type">LessThanZero</span> <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span></div><div class="line"></div><div class="line"><span class="title">sqrtIO</span> :: (<span class="type">SqrtException</span> -&gt; <span class="type">ContT</span> r <span class="type">IO</span> ()) -&gt; <span class="type">ContT</span> r <span class="type">IO</span> ()</div><div class="line"><span class="title">sqrtIO</span> throw = <span class="keyword">do</span> </div><div class="line">    ln &lt;- lift (putStr <span class="string">"Enter a number to sqrt: "</span> &gt;&gt; readLn)</div><div class="line">    when (ln &lt; <span class="number">0</span>) (throw <span class="type">LessThanZero</span>)</div><div class="line">    lift $ print (sqrt ln)</div><div class="line"></div><div class="line"><span class="title">main</span> = runContT (tryCont sqrtIO (lift . print)) return</div></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>throw</code>意味着从封闭的<code>callCC</code>中逃脱(<code>escape</code>)了，这个<code>throw</code>原本在<code>tryCont</code>的内部<code>callCC</code>中。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/34064655" target="_blank" rel="external">柯里化的前生今世（八）：尾调用与CPS</a><br><a href="https://en.wikipedia.org/wiki/Continuation-passing_style#CPS_in_Haskell" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuation-passing_style#CPS_in_Haskell</a><br><a href="https://en.m.wikibooks.org/wiki/Haskell/Continuation_passing_style#callCC" target="_blank" rel="external">https://en.m.wikibooks.org/wiki/Haskell/Continuation_passing_style#callCC</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和我同乘时光机。&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="计算原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Haskell" scheme="http://gaufoo.com/tags/Haskell/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用Haskell构建Parser Combinator（一）</title>
    <link href="http://gaufoo.com/parser/"/>
    <id>http://gaufoo.com/parser/</id>
    <published>2018-03-09T18:28:27.000Z</published>
    <updated>2018-03-12T01:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>某高中生眼中入门级别的程序。</p>
<a id="more"></a>
<hr>
<h1 id="本文要点"><a href="#本文要点" class="headerlink" title="本文要点"></a>本文要点</h1><h2 id="你将收获"><a href="#你将收获" class="headerlink" title="你将收获"></a>你将收获</h2><ul>
<li>了解Parser Combinator的概念、特点以及使用方法。</li>
<li>学会用Haskell亲手构建简单却实用的Parser Combinator。</li>
<li>加深对Monad的理解。</li>
</ul>
<h2 id="所需基础"><a href="#所需基础" class="headerlink" title="所需基础"></a>所需基础</h2><ul>
<li>简单了解Haskell语法即可。</li>
</ul>
<hr>
<h1 id="Parser-Combinator-概念"><a href="#Parser-Combinator-概念" class="headerlink" title="Parser Combinator 概念"></a>Parser Combinator 概念</h1><p><strong>什么是Parser：</strong><br>简单地说：给定一个字符流，比如一个字符串、一段代码、一篇文章等，输入到Parser，会把原本平坦的结构改造成有层次有内涵的结构。</p>
<p><strong>什么是Parser Combinator：</strong><br>由于函数式语言里函数是头等公民，可以把一个函数作为另一个函数的参数，一个函数可以产生出另外一个函数。基于这样的特点，我们可以把一个Parser作为参数传给另外一个Parser，一个Parser也可以产生另外一个新的Parser。有了这样的结合性，我们就可以实现Parser Combinator。<br>它是一种基于递归下降原理的非常简洁的Parser实现方法。</p>
<p><strong>为什么是Parser Combinator：</strong><br>Parser Combinator在模块化、可读性、易维护等方面有着无可比拟的优势。<br>举个简单的例子：就像小孩子读文章，一开始他只认识一个一个字，拿着手指一个字一个字地点着读。接着他学会了把字结合起来变成词，认识词后又学会如何识别句子（很可能是因为学会了标点符号），慢慢长大后他便一目十行，脑中自然形成了文章的概念。Parser Combinator就很像这样一步一步组合的过程，非常符合人类直觉，所以编写起来相当容易。</p>
<p><strong>编写语言：</strong><br>Haskell，不想写C++找罪受。<br>注：演示代码将尽量详细，所以可能不够point-free。</p>
<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>第一步，先定义Parser的数据类型。<br>还记得我上面说过，Parser是将字符流转换成一种结构，比如<code>Tree</code>。所以可以适当猜想一下数据类型的样子：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">Parser</span> = <span class="type">String</span> -&gt; <span class="type">Tree</span></span></div></pre></td></tr></table></figure></p>
<p>但显然不可能这样一步到位，一个<code>Parser</code>直接生成一棵树，那还谈什么结合。按道理，应该是一个Parser接受字符串，消耗一定字符，产生特定的结构，完成后把剩余的字符交给下一个<code>Parser</code>继续解析：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">Parser</span> = <span class="type">String</span> -&gt; (<span class="type">Tree</span>, <span class="type">String</span>)</span></div></pre></td></tr></table></figure></p>
<p>这个看起来还行，不过只能产生<code>Tree</code>这种数据结构。我们不应该给它这样的限制，而是允许使用者自由地决定解析什么数据结构，所以把<code>Tree</code>抽象成任意具体类型。<br>最后再加上代表解析失败的信号，就形成了一个可用的<code>Parser</code>类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Parser</span> a = <span class="type">Parser</span> (<span class="type">String</span> -&gt; <span class="type">Maybe</span> (<span class="title">a</span>, <span class="type">String</span>))</span></div></pre></td></tr></table></figure></p>
<p>解析失败将返回<code>Nothing</code>。</p>
<hr>
<h1 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h1><p>在最开始的地方，就让我们写个最简单的，能够解析一个特定字符的的<code>Parser</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">char</span> :: <span class="type">Char</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></div></pre></td></tr></table></figure></p>
<p>接受一个字符，返回解析该字符的<code>Parser</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">char</span> :: <span class="type">Char</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">char</span> c = <span class="type">Parser</span> $ \str -&gt;</div><div class="line">  <span class="keyword">case</span> str <span class="keyword">of</span></div><div class="line">    <span class="string">""</span> -&gt; <span class="type">Nothing</span></div><div class="line">    (x:xs) -&gt; <span class="keyword">if</span> x == c </div><div class="line">                <span class="keyword">then</span> <span class="type">Just</span> (x, xs) </div><div class="line">                <span class="keyword">else</span> <span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>为了测试效果，还得实现一个运行函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">runParse</span> :: <span class="type">Parser</span> a -&gt; <span class="type">String</span> -&gt; <span class="type">Maybe</span> (a, <span class="type">String</span>)</div><div class="line"><span class="title">runParse</span> (<span class="type">Parser</span> psr) str = psr str</div></pre></td></tr></table></figure></p>
<p>终端：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (char 'a') <span class="string">"abc"</span></div><div class="line"><span class="type">Just</span> ('a',<span class="string">"bc"</span>)</div><div class="line">λ&gt; runParse (char 'a') <span class="string">"b"</span></div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<ol>
<li>解析 a 字符。给定 “abc” 字符串，字符串消耗一个 ‘a’ ，返回一个 ‘a’ ，剩余字符串为 “bc” 。</li>
<li>解析 a 字符。给定 “b” 字符串，解析失败，返回 Nothing 。</li>
</ol>
<p>太好了，莫大的鼓励。</p>
<hr>
<h1 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h1><h2 id="satisfy"><a href="#satisfy" class="headerlink" title="satisfy"></a>satisfy</h2><p>上面简单实现了<code>char</code>。不过，是否可以略微抽象一下呢。不一定要相等，只要满足给定的条件就算解析成功。<br>相信读者已经想到了，把<code>Char</code>改成函数<code>Char -&gt; Bool</code>不就可以了吗，就取名作<code>satisfy</code>吧：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">satisfy</span> :: (<span class="type">Char</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">satisfy</span> prd = <span class="type">Parser</span> $ \str -&gt;</div><div class="line">  <span class="keyword">case</span> str <span class="keyword">of</span></div><div class="line">    <span class="string">""</span> -&gt; <span class="type">Nothing</span></div><div class="line">    (x:xs) -&gt; <span class="keyword">if</span> prd x </div><div class="line">                <span class="keyword">then</span> <span class="type">Just</span> (x, xs) </div><div class="line">                <span class="keyword">else</span> <span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>对比上面的<code>char</code>，这里只是把<code>if</code>右边的判断语句改了一下，就实现了更丰富的功能。</p>
<p>既然<code>satisfy</code>是由<code>char</code>抽象而来的，那么<code>char</code>应该也可以由<code>satisfy</code>实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">char</span> :: <span class="type">Char</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 改写char实现</span></div><div class="line"><span class="title">char</span> c = satisfy $ \x -&gt; x == c</div></pre></td></tr></table></figure></p>
<p>不仅如此，现在因为有了<code>satisfy</code>，从<code>Data.Char</code>包里找到一些<code>Char -&gt; Bool</code>的函数，我们就又可以实现一大堆<code>Parser</code>了：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Data.Char</div><div class="line"></div><div class="line">...</div><div class="line">...</div><div class="line"></div><div class="line"><span class="title">space</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析空格</span></div><div class="line"><span class="title">space</span> = satisfy isSpace</div><div class="line"></div><div class="line"><span class="title">digit</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析十进制数字</span></div><div class="line"><span class="title">digit</span> = satisfy isDigit</div><div class="line"></div><div class="line"><span class="title">lower</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析小写字母</span></div><div class="line"><span class="title">lower</span> = satisfy isLower</div><div class="line"></div><div class="line"><span class="title">upper</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析大写字母</span></div><div class="line"><span class="title">upper</span> = satisfy isUpper</div><div class="line"></div><div class="line"><span class="title">letter</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析字母</span></div><div class="line"><span class="title">letter</span> = satisfy isLetter</div><div class="line"></div><div class="line"><span class="title">alphanum</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析字母和数字</span></div><div class="line"><span class="title">alphanum</span> = satisfy isAlphaNum</div><div class="line"></div><div class="line"><span class="title">hexDigit</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析十六进制数字</span></div><div class="line"><span class="title">hexDigit</span> = satisfy isHexDigit</div><div class="line"></div><div class="line"><span class="title">octDigit</span> :: <span class="type">Parser</span> <span class="type">Char</span> <span class="comment">-- 解析八进制数字</span></div><div class="line"><span class="title">octDigit</span> = satisfy isOctDigit</div></pre></td></tr></table></figure>
<p>赚大了，简直是买一送十，实现个<code>satisfy</code>白拿这么多<code>Parser</code>。</p>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse letter <span class="string">"bc"</span></div><div class="line"><span class="type">Just</span> ('b',<span class="string">"c"</span>)</div><div class="line">λ&gt; runParse digit <span class="string">"123"</span></div><div class="line"><span class="type">Just</span> ('<span class="number">1</span>',<span class="string">"23"</span>)</div><div class="line">λ&gt; runParse digit <span class="string">"abc"</span></div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>还有这两个相当有用的<code>Parser</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">oneOf</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">oneOf</span> cs = satisfy (`elem` cs) <span class="comment">-- 解析给定字符串里的其中一个Char</span></div><div class="line"></div><div class="line"><span class="title">noneOf</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></div><div class="line"><span class="title">noneOf</span> cs = satisfy (not . (`elem` cs)) <span class="comment">-- 解析给定字符串以外的任何Char</span></div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (oneOf <span class="string">"abc"</span>) <span class="string">"biiii"</span></div><div class="line"><span class="type">Just</span> ('b',<span class="string">"iiii"</span>)</div><div class="line">λ&gt; runParse (noneOf <span class="string">"abc"</span>) <span class="string">"iiii"</span></div><div class="line"><span class="type">Just</span> ('i',<span class="string">"iii"</span>)</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>尽管上面已经实现了很多<code>Parser</code>，但我们发现它们都是解析<code>Char</code>类型的，不能就此停下脚步。<br>现在尝试一下实现解析多个<code>Char</code>的<code>Parser</code>，也就是<code>String</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">string</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></div><div class="line"><span class="title">string</span> <span class="string">""</span> = <span class="type">Parser</span> $ \s -&gt; <span class="type">Just</span> (<span class="string">""</span>, s) <span class="comment">-- 空字符串，解析成功</span></div><div class="line"><span class="title">string</span> (x:xs) = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">  <span class="keyword">case</span> runParse (char x) inp <span class="keyword">of</span> <span class="comment">-- 解析第一个字符</span></div><div class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">    <span class="type">Just</span> (r, rest) -&gt; <span class="keyword">case</span> runParse (string xs) rest <span class="keyword">of</span> <span class="comment">-- 解析剩余字符串</span></div><div class="line">                        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">                        <span class="type">Just</span> (rs, outp) -&gt; <span class="type">Just</span> (r:rs, outp) <span class="comment">-- 连接字符和字符串</span></div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (string <span class="string">"abc"</span>) <span class="string">"abc"</span></div><div class="line"><span class="type">Just</span> (<span class="string">"abc"</span>,<span class="string">""</span>)</div><div class="line">λ&gt; runParse (string <span class="string">"abc"</span>) <span class="string">"ab"</span></div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure></p>
<p>这里使用了递归，看起来似乎有点复杂，嵌套了两层<code>case</code>，但在注释的帮助下，相信读者能够轻松理解。</p>
<hr>
<h2 id="Combinator"><a href="#Combinator" class="headerlink" title="Combinator"></a>Combinator</h2><p>也许会有读者问到，我们仅仅是解析一串字符串，都要嵌套来嵌套去，这就是所谓的可读性和易构建吗？<br>这个问题问得非常好。假设我们要连续解析多个类型，如果继续按照上面的做法，很可能会产生一大串<code>case</code>链，这是非常难写和难懂的。<br>这个问题的解决，还是只有那个办法 —— 抽象。</p>
<p>要在旧的<code>Parser</code>产生的结果的基础上构造新的另外一种类型的<code>Parser</code>，可以这样做：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">bind</span> :: <span class="type">Parser</span> a -&gt; (a -&gt; <span class="type">Parser</span> b) -&gt; <span class="type">Parser</span> b</div><div class="line"><span class="title">pa</span> `bind` apb = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">  <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">    <span class="type">Just</span> (a, rest) -&gt; <span class="keyword">let</span> (<span class="type">Parser</span> pb) = apb a</div><div class="line">                      <span class="keyword">in</span> pb rest</div></pre></td></tr></table></figure></p>
<p>第二个参数<code>a -&gt; Parser b</code>实际上只是一个幌子，它最大的作用是把第一个<code>Parser a</code>的结果<code>a</code>「骗」出来。平时使用时通常写成一个<code>lambda</code>表达式，然后在这个<code>lambda</code>里专注于<code>Parser b</code>的实现。<br>若一头雾水，请留意接下来的演示。</p>
<p>用它来重新写<code>string</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">string</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></div><div class="line"><span class="title">string</span> <span class="string">""</span> = lift <span class="string">""</span></div><div class="line"><span class="title">string</span> (x:xs) = char x `bind` \s -&gt;       <span class="comment">-- 「骗」出char的结果s</span></div><div class="line">                string xs `bind` \ss -&gt;   <span class="comment">-- 「骗」出剩余string的结果ss</span></div><div class="line">                lift (s:ss)               <span class="comment">-- 返回结构Parser</span></div><div class="line"></div><div class="line"><span class="title">lift</span> :: a -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">lift</span> x = <span class="type">Parser</span> $ \inp -&gt; <span class="type">Just</span> (x, inp)</div></pre></td></tr></table></figure></p>
<p><code>lift</code>函数不消耗字符串，只为把<code>Parser</code>结构补上。</p>
<p>如此奇妙的思路，如此精巧的实现，当然这不是我这种普通人能够「显而易见」的。<br>在此致敬相关数学家。</p>
<hr>
<h1 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h1><p>躲不过的，躲不过的。写Haskell无论如何都是是躲不过Monad的。</p>
<hr>
<p>Haskell上<code>bind</code>语法的简化版：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">string</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></div><div class="line"><span class="title">string</span> <span class="string">""</span> = return <span class="string">""</span></div><div class="line"><span class="title">string</span> (x:xs) = <span class="keyword">do</span></div><div class="line">  s  &lt;- char x     <span class="comment">-- char x解析结果绑定到s上</span></div><div class="line">  ss &lt;- string xs  <span class="comment">-- string xs解析结果绑定到ss上</span></div><div class="line">  return (s:ss)    <span class="comment">-- 返回结构Parser</span></div></pre></td></tr></table></figure></p>
<p>看起来更加清晰自然，这才是<code>Combinator</code>应有的样子。<br>想要得到这种<code>do</code>语法，只需要将<code>Parser</code>类型实现<code>Monad</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">λ&gt; :t (&gt;&gt;=)</div><div class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line">λ&gt; :t bind</div><div class="line"><span class="title">bind</span> :: <span class="type">Parser</span> a -&gt; (a -&gt; <span class="type">Parser</span> b) -&gt; <span class="type">Parser</span> b</div><div class="line">λ&gt; :t return</div><div class="line"><span class="title">return</span> :: <span class="type">Monad</span> m =&gt; a -&gt; m a</div><div class="line">λ&gt; :t lift</div><div class="line"><span class="title">lift</span> :: a -&gt; <span class="type">Parser</span> a</div></pre></td></tr></table></figure></p>
<p>其实我们已经实现了<code>Monad</code>需要的<code>(&gt;&gt;=)</code>和<code>return</code>函数，但由于还未实现<code>Monad</code>的前置范畴<code>Functor</code>和<code>Applicative</code>，所以暂时还不能<code>instance Monad</code>。<code>Functor</code>和<code>Applicative</code>也是很有用的范畴，下面就来实现一下。</p>
<hr>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">λ&gt; :i <span class="type">Functor</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span></div><div class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</div><div class="line">  (&lt;$) :: a -&gt; f b -&gt; f a</div><div class="line">  <span class="meta">&#123;-# MINIMAL fmap #-&#125;</span></div></pre></td></tr></table></figure>
<p>最少实现：<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code><br>下面来尝试一下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  fmap f pa = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">      <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">      <span class="type">Just</span> (x, rest) -&gt; <span class="type">Just</span> (f x, rest)</div></pre></td></tr></table></figure></p>
<p><code>fmap</code>需要提供一个函数<code>a -&gt; b</code>和一个<code>Parser a</code>，然后就可以产生另外一个<code>Parser b</code>。</p>
<hr>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">λ&gt; :i <span class="type">Applicative</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span></div><div class="line">  pure :: a -&gt; f a</div><div class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</div><div class="line">  <span class="type">GHC</span>.<span class="type">Base</span>.liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</div><div class="line">  (*&gt;) :: f a -&gt; f b -&gt; f b</div><div class="line">  (&lt;*) :: f a -&gt; f b -&gt; f a</div><div class="line">  <span class="meta">&#123;-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-&#125;</span></div></pre></td></tr></table></figure>
<p>最少实现：<code>pure :: a -&gt; f a</code>、<code>(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<ul>
<li><p><code>pure</code>已经实现过了，就是上面的<code>lift</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">pure</span> x = <span class="type">Parser</span> $ \inp -&gt; <span class="type">Just</span> (x, inp)</div></pre></td></tr></table></figure>
</li>
<li><p><code>lift</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">pab</span> &lt;*&gt; pa = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">  <span class="keyword">case</span> runParse pab inp <span class="keyword">of</span></div><div class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">    <span class="type">Just</span> (fab, rest) -&gt; runParse (fmap fab pa) rest</div></pre></td></tr></table></figure>
</li>
<li><p>合起来：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line"><span class="title">pure</span> x = <span class="type">Parser</span> $ \inp -&gt; <span class="type">Just</span> (x, inp)</div><div class="line"><span class="title">pab</span> &lt;*&gt; pa = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">  <span class="keyword">case</span> runParse pab inp <span class="keyword">of</span></div><div class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">    <span class="type">Just</span> (fab, rest) -&gt; runParse (fmap fab pa) rest</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Monad-1"><a href="#Monad-1" class="headerlink" title="Monad"></a>Monad</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">λ&gt; :i <span class="type">Monad</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></div><div class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</div><div class="line">  return :: a -&gt; m a</div><div class="line">  fail :: <span class="type">String</span> -&gt; m a</div><div class="line">  <span class="meta">&#123;-# MINIMAL (&gt;&gt;=) #-&#125;</span></div></pre></td></tr></table></figure>
<p>最少实现：<code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code></p>
<p>直接复制上面的<code>bind</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  pa &gt;&gt;= apb = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">      <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></div><div class="line">      <span class="type">Just</span> (a, rest) -&gt; runParse (apb a) rest</div></pre></td></tr></table></figure>
<ul>
<li><p>用<code>Monad</code>改写<code>string</code>：</p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">string</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></div><div class="line"><span class="title">string</span> <span class="string">""</span> = return <span class="string">""</span></div><div class="line"><span class="title">string</span> (x:xs) = <span class="keyword">do</span></div><div class="line">  s  &lt;- char x </div><div class="line">  ss &lt;- string xs</div><div class="line">  return (s:ss)</div></pre></td></tr></table></figure>
<p>  测试：</p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (string <span class="string">"abc"</span>) <span class="string">"abcd"</span></div><div class="line"><span class="type">Just</span> (<span class="string">"abc"</span>,<span class="string">"d"</span>)</div><div class="line">λ&gt; runParse (string <span class="string">"abcde"</span>) <span class="string">"abcd"</span></div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure>
</li>
<li><p>用<code>Functor</code>和<code>Applicative</code>改写<code>string</code>：</p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">string</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></div><div class="line"><span class="title">string</span> <span class="string">""</span>     = return <span class="string">""</span></div><div class="line"><span class="title">string</span> (x:xs) = (:) &lt;$&gt; char x &lt;*&gt; string xs</div></pre></td></tr></table></figure>
<p>  测试：</p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (string <span class="string">"abc"</span>) <span class="string">"abcd"</span></div><div class="line"><span class="type">Just</span> (<span class="string">"abc"</span>,<span class="string">"d"</span>)</div><div class="line">λ&gt; runParse (string <span class="string">"abcde"</span>) <span class="string">"abcd"</span></div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="选择与回溯"><a href="#选择与回溯" class="headerlink" title="选择与回溯"></a>选择与回溯</h1><p>尽管有上面的<code>Monad</code>，我们已经可以构建绝大多数的<code>Parser</code>了。<br>但当我们常常希望解析同样的值多次，或是尝试解析<code>a</code>失败后继续解析<code>b</code>。<br>幸运的是，只要<code>instance Alternative</code>，就能一次性获得以上好处。</p>
<p>首先需要<code>import</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Control.Applicative</div></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">λ&gt; :i <span class="type">Alternative</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> f =&gt; <span class="type">Alternative</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span></div><div class="line">  empty :: f a</div><div class="line">  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a</div><div class="line">  some :: f a -&gt; f [a]</div><div class="line">  many :: f a -&gt; f [a]</div><div class="line">  <span class="meta">&#123;-# MINIMAL empty, (&lt;|&gt;) #-&#125;</span></div></pre></td></tr></table></figure>
<p>只要实现<code>empty</code>和<code>&lt;|&gt;</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">Parser</span> <span class="keyword">where</span></span></div><div class="line">  empty = <span class="type">Parser</span> $ const <span class="type">Nothing</span></div><div class="line">  pa &lt;|&gt; pb = <span class="type">Parser</span> $ \inp -&gt;</div><div class="line">    <span class="keyword">case</span> runParse pa inp <span class="keyword">of</span></div><div class="line">      <span class="type">Nothing</span> -&gt; runParse pb inp</div><div class="line">      x -&gt; x</div></pre></td></tr></table></figure></p>
<p>注：这里发生了件很微妙的事情 —— 这里的<code>&lt;|&gt;</code>实现是必回溯的，也就是说，如果左边的<code>pa</code>失败了，则<code>pb</code>会从头开始解析。</p>
<hr>
<p>现在我们有了<code>some</code>、<code>many</code>、<code>&lt;|&gt;</code>，可以用来做一些更酷的事情。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">skipMany</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> ()</div><div class="line"><span class="title">skipMany</span> p = many p &gt;&gt; return ()</div><div class="line"><span class="title">skipMany1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> ()</div><div class="line"><span class="title">skipMany1</span> p = some p &gt;&gt; return ()</div></pre></td></tr></table></figure>
<p>注：<code>&gt;&gt;</code>是<code>&gt;&gt;=</code>的丢弃结果版本，<code>a &gt;&gt; b</code>相当于<code>a &gt;&gt;= \_ -&gt; b</code>。带<code>1</code>的函数代表至少解析一个值，对应<code>some</code>。</p>
<p>测试：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (skipMany space &gt;&gt; char 'a') <span class="string">"    a"</span></div><div class="line"><span class="type">Just</span> ('a',<span class="string">""</span>)</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><h2 id="between"><a href="#between" class="headerlink" title="between"></a>between</h2><p>通常用来解析括号之间的值，利用<code>Applicative</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">between</span> :: <span class="type">Parser</span> open -&gt; <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> close -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">between</span> o a c = o *&gt; a &lt;* c</div></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (between (char '(') digit (char ')')) <span class="string">"(2)"</span></div><div class="line"><span class="type">Just</span> ('<span class="number">2</span>',<span class="string">""</span>)</div></pre></td></tr></table></figure>
<h2 id="sepBy"><a href="#sepBy" class="headerlink" title="sepBy"></a>sepBy</h2><p>通常用来解析列表形式的值，每个值之间用特定分隔符隔开，解析成功则返回值的列表。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">sepBy1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> sep -&gt; <span class="type">Parser</span> [a]</div><div class="line"><span class="title">sepBy1</span> p sep = <span class="keyword">do</span></div><div class="line">  a &lt;- p</div><div class="line">  <span class="keyword">as</span> &lt;- many (sep &gt;&gt; p)</div><div class="line">  return $ a:<span class="keyword">as</span></div><div class="line"></div><div class="line"><span class="title">sepBy</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> sep -&gt; <span class="type">Parser</span> [a]</div><div class="line"><span class="title">sepBy</span> p sep = sepBy1 p sep &lt;|&gt; return []</div></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (sepBy (many letter) (oneOf <span class="string">" "</span>)) <span class="string">"abc def fg b"</span></div><div class="line"><span class="type">Just</span> ([<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"fg"</span>,<span class="string">"b"</span>],<span class="string">""</span>)</div></pre></td></tr></table></figure>
<h2 id="endBy"><a href="#endBy" class="headerlink" title="endBy"></a>endBy</h2><p>和<code>sepBy</code>的区别是，<code>endBy</code>末尾还有分隔符。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">endBy</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> sep -&gt; <span class="type">Parser</span> [a]</div><div class="line"><span class="title">endBy</span> p sep = many (p &lt;* sep)</div><div class="line"></div><div class="line"><span class="title">endBy1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> sep -&gt; <span class="type">Parser</span> [a]</div><div class="line"><span class="title">endBy1</span> p sep = some (p &lt;* sep)</div></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse (endBy (many letter) (oneOf <span class="string">" "</span>)) <span class="string">"abc def fg b "</span></div><div class="line"><span class="type">Just</span> ([<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"fg"</span>,<span class="string">"b"</span>],<span class="string">""</span>)</div></pre></td></tr></table></figure>
<h2 id="chainl"><a href="#chainl" class="headerlink" title="chainl"></a>chainl</h2><p>左结合，需要提供结合两个值的函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="title">chainl1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> (a -&gt; a -&gt; a) -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">chainl1</span> p op = <span class="keyword">do</span></div><div class="line">  x &lt;- p</div><div class="line">  trav x</div><div class="line">  <span class="keyword">where</span> trav x_ = try (<span class="keyword">do</span> f &lt;- op</div><div class="line">                          y &lt;- p</div><div class="line">                          trav (f x_ y)) &lt;|&gt; return x_</div><div class="line"></div><div class="line"><span class="title">chainl</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> (a -&gt; a -&gt; a) -&gt; a -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">chainl</span> p op x = chainl1 p op &lt;|&gt; return x</div></pre></td></tr></table></figure>
<h2 id="chainr"><a href="#chainr" class="headerlink" title="chainr"></a>chainr</h2><p>右结合，需要提供结合两个值的函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="title">chainr1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> (a -&gt; a -&gt; a) -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">chainr1</span> p op = <span class="keyword">do</span></div><div class="line">  x &lt;- p</div><div class="line">  try (<span class="keyword">do</span> f &lt;- op</div><div class="line">          rest &lt;- chainr1 p op</div><div class="line">          return (f x rest)) &lt;|&gt; return x</div><div class="line"></div><div class="line"><span class="title">chainr</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> (a -&gt; a -&gt; a) -&gt; a -&gt; <span class="type">Parser</span> a</div><div class="line"><span class="title">chainr</span> p op x = chainr1 p op &lt;|&gt; return x</div></pre></td></tr></table></figure>
<hr>
<h1 id="实例：构造四则运算语法树"><a href="#实例：构造四则运算语法树" class="headerlink" title="实例：构造四则运算语法树"></a>实例：构造四则运算语法树</h1><h2 id="语法树数据结构"><a href="#语法树数据结构" class="headerlink" title="语法树数据结构"></a>语法树数据结构</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Op</span> = <span class="type">Add</span> | <span class="type">Sub</span> | <span class="type">Mul</span> | <span class="type">Div</span> <span class="keyword">deriving</span> (<span class="type">Eq</span>)</span></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">ExprTree</span> = <span class="type">Number</span> <span class="type">Int</span></span></div><div class="line">              | <span class="type">Node</span> <span class="type">Op</span> <span class="type">ExprTree</span> <span class="type">ExprTree</span> <span class="keyword">deriving</span> (<span class="type">Eq</span>)</div></pre></td></tr></table></figure>
<p>顺便<code>instance Show</code>，按S-表达式语法：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Op</span> <span class="keyword">where</span></span></div><div class="line">  show <span class="type">Add</span> = <span class="string">"+"</span></div><div class="line">  show <span class="type">Sub</span> = <span class="string">"-"</span></div><div class="line">  show <span class="type">Mul</span> = <span class="string">"*"</span></div><div class="line">  show <span class="type">Div</span> = <span class="string">"/"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">ExprTree</span> <span class="keyword">where</span></span></div><div class="line">  show (<span class="type">Number</span> x) = show x</div><div class="line">  show (<span class="type">Node</span> op l r) = <span class="string">"("</span> ++ show op ++ <span class="string">" "</span> ++ show l ++ <span class="string">" "</span> ++ show r ++ <span class="string">")"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Node</span> <span class="type">Add</span> (<span class="type">Number</span> <span class="number">1</span>) (<span class="type">Number</span> <span class="number">2</span>)</div><div class="line">(+ <span class="number">1</span> <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h2 id="解析数字"><a href="#解析数字" class="headerlink" title="解析数字"></a>解析数字</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">nature</span> :: <span class="type">Parser</span> <span class="type">Int</span></div><div class="line"><span class="title">nature</span> = read &lt;$&gt; some digit</div></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse nature <span class="string">"10086"</span></div><div class="line"><span class="type">Just</span> (<span class="number">10086</span>,<span class="string">""</span>)</div></pre></td></tr></table></figure>
<h2 id="Term-Factor-Expression"><a href="#Term-Factor-Expression" class="headerlink" title="Term Factor Expression"></a>Term Factor Expression</h2><p>读者可以参考<a href="http://gaufoo.com/2018/01/02/ni_to_pre_post/#%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">中缀表达式转化前后缀引发的思考</a>。</p>
<p>由于四则运算的结合性都是左结合，需要一个<code>Parser (a -&gt; a -&gt; a)</code>类型的结合函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">pNode</span> :: <span class="type">Op</span> -&gt; <span class="type">Parser</span> (<span class="type">ExprTree</span> -&gt; <span class="type">ExprTree</span> -&gt; <span class="type">ExprTree</span>)</div><div class="line"><span class="title">pNode</span> = return . <span class="type">Node</span></div></pre></td></tr></table></figure></p>
<h3 id="Exp-Factor-‘-’-‘-‘-Factor"><a href="#Exp-Factor-‘-’-‘-‘-Factor" class="headerlink" title="Exp = Factor (( ‘+’ | ‘-‘ ) Factor)*"></a>Exp = Factor (( ‘+’ | ‘-‘ ) Factor)*</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">expression</span> :: <span class="type">Parser</span> <span class="type">ExprTree</span></div><div class="line"><span class="title">expression</span> = chainl1 factor ((char '+' &gt;&gt; pNode <span class="type">Add</span>) &lt;|&gt; (char '-' &gt;&gt; pNode <span class="type">Sub</span>))</div></pre></td></tr></table></figure>
<h3 id="Factor-Term-‘-‘-‘-‘-Term"><a href="#Factor-Term-‘-‘-‘-‘-Term" class="headerlink" title="Factor = Term (( ‘*‘ | ‘/‘ ) Term)*"></a>Factor = Term (( ‘*‘ | ‘/‘ ) Term)*</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">factor</span> :: <span class="type">Parser</span> <span class="type">ExprTree</span></div><div class="line"><span class="title">factor</span> = chainl1 term ((char '*' &gt;&gt; pNode <span class="type">Mul</span>) &lt;|&gt; (char '/' &gt;&gt; pNode <span class="type">Div</span>))</div></pre></td></tr></table></figure>
<h3 id="Term-lt-数字-gt-‘-‘-Exp-‘-’"><a href="#Term-lt-数字-gt-‘-‘-Exp-‘-’" class="headerlink" title="Term = &lt;数字&gt; | ‘(‘ Exp ‘)’"></a>Term = &lt;数字&gt; | ‘(‘ Exp ‘)’</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">term</span> :: <span class="type">Parser</span> <span class="type">ExprTree</span></div><div class="line"><span class="title">term</span> = <span class="type">Number</span> &lt;$&gt; nature &lt;|&gt; between (char '(') expression (char ')')</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; runParse expression <span class="string">"2+5*7/(39+54)-7/6"</span></div><div class="line"><span class="type">Just</span> ((- (+ <span class="number">2</span> (/ (* <span class="number">5</span> <span class="number">7</span>) (+ <span class="number">39</span> <span class="number">54</span>))) (/ <span class="number">7</span> <span class="number">6</span>)),<span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>注意到，这里的原始式不能带空格。</p>
<p>练习：请读者自行实现一个允许带空格的四则运算<code>Parser</code>。</p>
<hr>
<h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h1><ul>
<li>本文实现的<code>Parser Combinator</code>的缺陷：不包含错误信息提示、<code>&lt;|&gt;</code>强制回溯等，将在下篇文章解决。</li>
<li>将带来更多的实例。</li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf" target="_blank" rel="external">Monadic Parser Combinators</a><br><a href="https://en.wikipedia.org/wiki/Parser_combinator" target="_blank" rel="external">https://en.wikipedia.org/wiki/Parser_combinator</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某高中生眼中入门级别的程序。&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Haskell" scheme="http://gaufoo.com/tags/Haskell/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用C++写出伪LISP代码（三）</title>
    <link href="http://gaufoo.com/cppnlisp3/"/>
    <id>http://gaufoo.com/cppnlisp3/</id>
    <published>2018-03-04T01:36:56.000Z</published>
    <updated>2018-03-04T04:22:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>迷。</p>
<a id="more"></a>
<hr>
<p>老规矩<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylist.h"</span></span></div></pre></td></tr></table></figure></p>
<hr>
<h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><p>设计一个迷宫游戏，给定迷宫的入口；如果存在出口，程序能够显示行走的路径，并最终到达出口，并输出“成功走出迷宫”；如果不存在出口，程序也能够显示行走的过程，并最终回退到入口，并输出“回退到入口”；</p>
<hr>
<h1 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h1><p><img src="/images/180303/photo_2333.gif"></p>
<hr>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>要是以为这个作业的难度在于走迷宫，那就大错特错了。走迷宫不要太简单，像我这样完全没接触过OI、ACM的普通学生，一般都能想到用所谓的广度优先算法解决。<br>实际上，这个问题困难的地方在于生成迷宫，如何生成一个有且仅有一条通路的、视觉效果还不赖的迷宫，是做这个作业最终要解决的问题。</p>
<hr>
<h1 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h1><p>既然走迷宫是很容易解决的问题，我们就先挑这个软柿子捏捏。</p>
<hr>
<h2 id="按意愿编程法"><a href="#按意愿编程法" class="headerlink" title="按意愿编程法"></a>按意愿编程法</h2><p>《SICP》提出过这么一种编程思路 —— 按意愿编程。意思是，先别管你写的程序能不能跑，假装代码中的所有函数都能正常工作，尽管实际上还没实现。这个办法能让人从细节的纠缠中脱离，从大局出发，每次专注于某个功能的实现。<br>当初我用Scheme来写走迷宫就采用了这样的办法，所以非常快地解决了问题。</p>
<hr>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><p>是该有这么一个<code>find_way</code>函数，功能是这样的：查看走出迷宫没有，如果没有，那就走下一步，再查看走出迷宫没有，如果没有，那就走下一步，……，直至走出迷宫。<br><code>find_shortest_way</code>函数就是按意愿编程法的产物，因为我还没实现它，只是期望它能够帮我查找<code>ways</code>的所有路线中是否存在某条路线走出了迷宫。若找到了这条路线，<code>find_way</code>就圆满完成了任务，返回这条最短路线。<br>接下来的<code>for</code>循环，是由于我的<code>Map</code>函数不够完善而临时采用的遍历操作。它利用假想的<code>next_steps</code>函数，让<code>ways</code>中的每条路线都走出下一步，然后把这些“下一步”存储在<code>poor_new_ways</code>中。叫<code>poor</code>的原因是，我假想的<code>next_steps</code>函数直接产生上下左右四个新位置，还需要下一步的过滤操作。<br>过滤操作利用<code>is_forwardable</code>，就可以筛选出真正可以走的下一步。<br>最后再递归进行如上操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">Way <span class="title">find_way</span><span class="params">(MyWayList ways)</span> </span>&#123;</div><div class="line">  <span class="keyword">auto</span> shortest_way&#123;find_shortest_way(ways)&#125;;</div><div class="line">  <span class="keyword">if</span> (!(shortest_way == EmptyCorList)) &#123;</div><div class="line">    <span class="keyword">return</span> shortest_way;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">auto</span> poor_new_ways&#123;EmptyWayList&#125;;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> old_ways = ways</div><div class="line">        ; old_ways != EmptyWayList</div><div class="line">        ; poor_new_ways = Append(next_steps(old_ways-&gt;head()), poor_new_ways)</div><div class="line">        , old_ways = old_ways-&gt;tail()) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> find_way(Filter([<span class="keyword">this</span>](Way way) &#123; <span class="keyword">return</span> is_forwardable(way-&gt;head()); &#125;,</div><div class="line">                    poor_new_ways));    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面再去实现上面所需要的子函数。</p>
<hr>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>生成某条路线的所有可能的下一步。<code>first</code>、<code>second</code>分别代表坐标<code>x</code>、<code>y</code>。<code>C</code>函数用于构造坐标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyWayList <span class="title">next_steps</span><span class="params">(Way way)</span> </span>&#123;</div><div class="line">  <span class="keyword">auto</span> last_pstion&#123;way-&gt;head()&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> d&#123;Cons(C(last_pstion-&gt;first + <span class="number">1</span>, last_pstion-&gt;second), way)&#125;;</div><div class="line">  <span class="keyword">auto</span> u&#123;Cons(C(last_pstion-&gt;first - <span class="number">1</span>, last_pstion-&gt;second), way)&#125;;</div><div class="line">  <span class="keyword">auto</span> l&#123;Cons(C(last_pstion-&gt;first, last_pstion-&gt;second - <span class="number">1</span>), way)&#125;;</div><div class="line">  <span class="keyword">auto</span> r&#123;Cons(C(last_pstion-&gt;first, last_pstion-&gt;second + <span class="number">1</span>), way)&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> toList(&#123; d, u, l, r &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="可达与否"><a href="#可达与否" class="headerlink" title="可达与否"></a>可达与否</h2><p>下一步不可达的情况是：走出了边界范围、撞了墙、走了别的路线走过的位置。<br>需要特别提出的是：走了别的路线走过的位置。感觉这是一种挺精巧的想法：既然你慢了一步，不是第一条走这个位置的路线，你就已经失去了成为最短路线的可能，淘汰吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_forwardable</span><span class="params">(CorP step)</span> </span>&#123;</div><div class="line">  <span class="keyword">auto</span> not_out_of_bound = [=]() -&gt; <span class="keyword">bool</span> &#123;</div><div class="line">    <span class="keyword">auto</span> x_&#123;step-&gt;first&#125;;</div><div class="line">    <span class="keyword">auto</span> y_&#123;step-&gt;second&#125;;</div><div class="line">    <span class="keyword">return</span> (x_ &lt; xbound) &amp;&amp; (y_ &lt; ybound) &amp;&amp; (x_ &gt;= <span class="number">0</span>) &amp;&amp; (y_ &gt;= <span class="number">0</span>);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> not_wall = [=]() -&gt; <span class="keyword">bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> step != wall; <span class="comment">// 伪代码，取决于具体实现</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> not_been = [=]() -&gt; <span class="keyword">bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> step != been; <span class="comment">// 伪代码，取决于具体实现</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> not_out_of_bound() &amp;&amp; not_wall() &amp;&amp; not_been();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="到达终点与否"><a href="#到达终点与否" class="headerlink" title="到达终点与否"></a>到达终点与否</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">Way <span class="title">find_shortest_way</span><span class="params">(MyWayList ways)</span> </span>&#123;</div><div class="line">  <span class="keyword">auto</span> is_reached = [=](Way way) -&gt; <span class="keyword">bool</span> &#123;</div><div class="line">    <span class="keyword">auto</span> step = way-&gt;head();</div><div class="line">    <span class="keyword">return</span> (step-&gt;first == destination-&gt;first &amp;&amp;</div><div class="line">      step-&gt;second == destination-&gt;second);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> reachs&#123;Filter(is_reached, ways)&#125;;</div><div class="line">  <span class="keyword">return</span> (reachs == EmptyWayList) ? EmptyCorList : reachs-&gt;head();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>到此，走迷宫的代码已经完成。马上迎来重头戏：生成迷宫。</p>
<hr>
<h1 id="生成迷宫"><a href="#生成迷宫" class="headerlink" title="生成迷宫"></a>生成迷宫</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先看到这样一个有望成为迷宫的胚子：<br><img src="/images/180303/photo_2018-03-04_11-02-31.jpg"><br>我们需要做的是，把某些墙推倒，解放每个格子(cell)。离散数学中的最小生成树算法就派上了用场。<br>把每个格子都当成一个结点，让所有格子连成一棵树。树的每两个结点，都必定只有一条最短路径可达。这样恰好就是一个迷宫。<br>既然是最小生成树，那么每个结点的权重是多少？这里假设每个格子的东南西北四个方向邻接的格子权重相同，与其他格子的距离无限大。并采用随机挑选的办法来处理权重相同的结点。</p>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>Prim算法是比较简单的最小生成树算法。我把这种思路整理成了如下的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">未连通::Set &lt;- All</div><div class="line">已连通::Set &lt;- []</div><div class="line">待连通::Set &lt;- []</div><div class="line"></div><div class="line">a &lt;- 未连通.RandomGet()</div><div class="line">已连通.Add(a)</div><div class="line">未连通.Remove(a)</div><div class="line"></div><div class="line">b[] &lt;- Filter(a.Around, 未连通)</div><div class="line">待连通.Add(b[])</div><div class="line">未连通.Remove(b[])</div><div class="line"></div><div class="line">while (not 待连通.EMPTY)</div><div class="line">&#123;</div><div class="line">    c &lt;- 待连通.RandomGet()</div><div class="line">    d[] &lt;- Filter(c.Around, 已连通)</div><div class="line"></div><div class="line">    e &lt;- d[].RandomGet()</div><div class="line">    Connect(c, e)</div><div class="line">    待连通.Remove(c)</div><div class="line">    已连通.Add(c)</div><div class="line">    </div><div class="line">    f[] &lt;- Filter(c.Around, 未连通)</div><div class="line">    待连通.Add(f[])</div><div class="line">    未连通.Remove(f[])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先明确，任何已连通的格子周围的格子都是待连通的格子。于是算法可以总结成：最开始先随机找到一个格子，加入已连通的集合。再从待连通集合里随机挑选一个格子，推倒它与已连通集合中随机挑选出的它周围的格子之间的墙。重复前过程直至待连通集合再无格子。<br>参考链接: <a href="http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm" target="_blank" rel="external">http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm</a></p>
<p>观察我的C++代码，基本与上述的伪代码一一对应：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">CorSet un;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</div><div class="line">    un.insert( Cor(x, y) );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">CorSet ed;</div><div class="line">CorSet ing;</div><div class="line"></div><div class="line"></div><div class="line">Cor a = *(<span class="built_in">std</span>::next(un.begin(), rand_int(<span class="number">0</span>, un.size())));</div><div class="line">ed.insert(a);</div><div class="line">un.erase(a);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> b&#123;filterAround(a, un)&#125;;</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : *b ) &#123; </div><div class="line">  ing.insert(x);</div><div class="line">  un.erase(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (!ing.empty()) &#123;</div><div class="line">  Cor c = *(<span class="built_in">std</span>::next(ing.begin(), rand_int(<span class="number">0</span>, ing.size())));</div><div class="line">  <span class="keyword">auto</span> d =  filterAround(c, ed);</div><div class="line"></div><div class="line">  Cor e = d-&gt;at(rand_int(<span class="number">0</span>, d-&gt;size()));</div><div class="line">  pullDown(c, e);</div><div class="line">  ing.erase(c);</div><div class="line">  ed.insert(c);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> f&#123;filterAround(c, un)&#125;;</div><div class="line">  <span class="keyword">for</span> ( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : *f ) &#123; </div><div class="line">    ing.insert(x);</div><div class="line">    un.erase(x);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>最后就会得到一个长这样的迷宫：<br><img src="/images/180303/photo_2018-03-04_11-32-17.jpg"></p>
<hr>
<p>寒假作业终于告一段落，要开始写周末作业了……<br>完整代码：<a href="https://github.com/zhongzc/C-/blob/master/maze.cpp" target="_blank" rel="external">https://github.com/zhongzc/C-/blob/master/maze.cpp</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迷。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
      <category term="编程" scheme="http://gaufoo.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/tags/C/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LISP" scheme="http://gaufoo.com/tags/LISP/"/>
    
  </entry>
  
  <entry>
    <title>用C++写出伪LISP代码（二）</title>
    <link href="http://gaufoo.com/cppnlisp2/"/>
    <id>http://gaufoo.com/cppnlisp2/</id>
    <published>2018-03-03T12:28:29.000Z</published>
    <updated>2018-03-04T04:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>既已有基础材料，撸起袖子做作业。</p>
<a id="more"></a>
<hr>
<p>什么都别说，先把<a href="http://gaufoo.com/2018/03/03/cppnlisp1/">用C++写出伪LISP代码（一）</a>写的代码include进来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylist.h"</span></span></div></pre></td></tr></table></figure></p>
<hr>
<h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><p>问题描述：<br>  设计一个程序实现两个任意长的正数（包括正数和负数）、任意精度实数的算术运算；<br>提示：<br>  （1）用动态链表存储数据，每节点含一个整型变量，表示若干位数；<br>  （2）整数输入和输出按中国对于长整数的习惯表示，每3位1组，组间用逗号隔开；<br>  （3）实现长整数的加、减运算；<br>  （4）程序运行界面清晰实用；<br>选做：<br>  （1）求两长整数之商、积<br>  （2）高精度实数算术运算</p>
<hr>
<h1 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h1><p><img src="/images/180303/photo_2018-03-03_20-43-54.gif"></p>
<hr>
<h1 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h1><p>要求3位3位地分割大数，对于我来说，很容易想到这是1000进制的加减乘除问题。因此问题转换成：如何实现任意进制的加减乘除。问题变得更通用，解决起来更有趣味和意义。</p>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>既然是用伪LISP代码来完成，首先明确结构就应该是<code>list</code>，用每个盒子的<code>head</code>来存储该每3位数。定义如下：<br>(*注：以下所有C++代码均采用C++14标准)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> IntList = MyList&lt;<span class="keyword">int</span>&gt;;</div><div class="line"><span class="keyword">auto</span> EmptyIntList = EmptyList&lt;<span class="keyword">int</span>&gt;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> base = <span class="number">1000</span>;</div><div class="line"><span class="comment">// 可以改成任意进制数，这里是1000进制</span></div><div class="line"><span class="keyword">int</span> highest_unit = base - <span class="number">1</span>;</div><div class="line"><span class="comment">// 每种进制的位最大表示数，如1000进制即999，10进制即为9，2进制即为1。</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>接触过计算机组成原理的读者都知道，计算机内部采用二进制补码形式表示数字。用补码来表示数字，可以有效简化一些运算。<br>遗憾的是，用补码并不能解决溢出问题，两个很大的正数相加，有可能会造成溢出，导致数位的循环，得到负数的结果。造成这样的结果原因是每个数字都只由有限的数位表示，一旦某些运算企图逾越这些数位的限制，便要承担运算错误的风险。<br>我决定也采用补码来进行进制运算，来获得运算的简化。但尽管我是在模拟进制运算，也采用补码，却由于可以动态申请内存，因此消除了溢出的风险，从而实现长整数运算。</p>
<p>至于什么是补码？简单地说：</p>
<ul>
<li>正数采用原有表示，但最高位添加符号位，为0。</li>
<li>0用0表示。</li>
<li>负数无视符号位，将所有位取反，再加1，最后最高位添加符号位，为进制最大表示数。</li>
</ul>
<p>想更为深入地了解何谓补码、为何用补码运算能简化计算，推荐阅读《编码》。</p>
<p>在这里，用一个<code>list</code>来存储一个补码表示的数字，最前面为最低位，<code>list</code>最深处则为最高位。</p>
<p>因此直接通过最高位来判断补码的正负性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(IntList n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> sign_digit = Reverse(n)-&gt;head();</div><div class="line">  <span class="keyword">return</span> sign_digit &gt;= (base / <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里放宽了条件，理论上最高位应该只可能是0或者进制最大表示数</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="补充与抛弃"><a href="#补充与抛弃" class="headerlink" title="补充与抛弃"></a>补充与抛弃</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">fill_low_digit</span><span class="params">(IntList, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">fill_high_digit</span><span class="params">(IntList, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">clip_high_digit</span><span class="params">(IntList, <span class="keyword">size_t</span>)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">clip_low_digit</span><span class="params">(IntList, <span class="keyword">size_t</span>)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>补充低位操作，这个较简单，直接往最前面填需要填充的数字即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  filler: 填充的数字  count: 填充位数</span></div><div class="line"><span class="function">IntList <span class="title">fill_low_digit</span><span class="params">(IntList n, <span class="keyword">int</span> filler, <span class="keyword">size_t</span> count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> (count == <span class="number">0</span>) ? n : Cons(filler, fill_low_digit(n, filler, count - <span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>补充高位操作，则需要翻转一下<code>list</code>，然后利用上面刚实现的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  filler: 填充的数字  count: 填充位数</span></div><div class="line"><span class="function">IntList <span class="title">fill_high_digit</span><span class="params">(IntList n, <span class="keyword">int</span> filler, <span class="keyword">size_t</span> count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> Reverse(fill_low_digit(Reverse(n), filler, count));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="抛弃"><a href="#抛弃" class="headerlink" title="抛弃"></a>抛弃</h4><p>抛弃高位，由于有自带的ListHead函数，可以直接调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  count: 抛弃位数</span></div><div class="line"><span class="function">IntList <span class="title">clip_high_digit</span><span class="params">(IntList n, <span class="keyword">size_t</span> count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> ListHead(n, Length(n) - count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抛弃低位，同理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  count: 抛弃位数</span></div><div class="line"><span class="function">IntList <span class="title">clip_low_digit</span><span class="params">(IntList n, <span class="keyword">size_t</span> count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> ListTail(n, count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="算术左移与右移"><a href="#算术左移与右移" class="headerlink" title="算术左移与右移"></a>算术左移与右移</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">shift_left</span><span class="params">(IntList, <span class="keyword">size_t</span>)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">shift_right</span><span class="params">(IntList, <span class="keyword">size_t</span>)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="算术左移"><a href="#算术左移" class="headerlink" title="算术左移"></a>算术左移</h4><p>可以直接抛弃高位，低位补0：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  count: 左移位数</span></div><div class="line"><span class="function">IntList <span class="title">shift_left</span><span class="params">(IntList n, <span class="keyword">size_t</span> count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> fill_low_digit(clip_high_digit(n, count), <span class="number">0</span>, count);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="算术右移"><a href="#算术右移" class="headerlink" title="算术右移"></a>算术右移</h4><p>抛弃低位，高位补充符号位：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  count: 右移位数</span></div><div class="line"><span class="function">IntList <span class="title">shift_right</span><span class="params">(IntList n, <span class="keyword">size_t</span> count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> raise_digits(clip_low_digit(n, count), Length(n));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>raise_digits</code>是用于提升位数的，这里只是借用。提升位数本质上是补充符号位的操作，补充符号位并不影响数值表示大小，下面来实现：</p>
<h3 id="位数提升"><a href="#位数提升" class="headerlink" title="位数提升"></a>位数提升</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// n: 补码  target_digits_length: 目标位数长度</span></div><div class="line"><span class="function">IntList <span class="title">raise_digits</span><span class="params">(IntList n, <span class="keyword">size_t</span> target_digits_length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">auto</span> pre_len&#123;Length(n)&#125;;</div><div class="line">  <span class="keyword">if</span> (pre_len &gt; target_digits_length) &#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">auto</span> count&#123;target_digits_length - pre_len&#125;;</div><div class="line">    <span class="keyword">return</span> is_negative(n) ?</div><div class="line">      fill_high_digit(n, highest_unit, count) :</div><div class="line">      fill_high_digit(n, <span class="number">0</span>, count);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，如果目标位数长度大于原位数长度，则不进行提升，直接返回原数。</p>
<h3 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h3><p>取反的意思是将每一位都取成进制最大表示数与其之差。取反需要遍历，遍历需要<code>fold</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">invert</span><span class="params">(IntList n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> FoldRight([](<span class="keyword">int</span> x, IntList xs) &#123; <span class="keyword">return</span> Cons(highest_unit - x, xs); &#125;, </div><div class="line">                       EmptyIntList, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="进位"><a href="#进位" class="headerlink" title="进位"></a>进位</h3><p>进位的重要性不言而喻，要保证进位后每一个位都不能超过进制最大表示数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_carry</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n / base; &#125;</div><div class="line"><span class="comment">// 用于计算某个位需要往高位进几</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_remain</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n % base; &#125;</div><div class="line"><span class="comment">// 用于计算某个位实际应当存放的数</span></div><div class="line"><span class="function">IntList <span class="title">carry</span><span class="params">(IntList n, <span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == EmptyIntList) &#123;</div><div class="line">    <span class="keyword">return</span> EmptyIntList;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">auto</span> neW&#123;n-&gt;head() + x&#125;;</div><div class="line">    <span class="keyword">auto</span> new_last_digit&#123;calc_remain(neW)&#125;;</div><div class="line">    <span class="keyword">auto</span> new_carry&#123;calc_carry(neW)&#125;;</div><div class="line">    <span class="keyword">return</span> Cons(new_last_digit, carry(n-&gt;tail(), new_carry));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="取负"><a href="#取负" class="headerlink" title="取负"></a>取负</h3><p>这个大家都应该很熟悉了，取负的操作 —— 取反加一！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">negate</span><span class="params">(IntList n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> carry(invert(n), <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="补码构造"><a href="#补码构造" class="headerlink" title="补码构造"></a>补码构造</h1><p>实现了各种位操作，终于可以用来构造补码了。<br>用户输入的正数形式为<code>123, 456, 789</code>，存储成<code>list</code>即为<code>(123, 456, 789)</code>，正好与补码形式相反，因此只需补充符号位，再翻转<code>list</code>即可。<br>负数形式为<code>-123, 456, 789</code>，存储成<code>list</code>即为<code>(-123, 456, 789)</code>，这里将第一位变成正数，借用构造正数的过程，最后再取负。<br>实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">make_number</span><span class="params">(IntList lst)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (Any([](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> x &lt; <span class="number">0</span>; &#125;, lst-&gt;tail())) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"###### 操作数输入错误：符号错误。"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (Any([=](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> <span class="built_in">abs</span>(x) &gt;= base; &#125;, lst)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"###### 操作数输入错误：每单元最多包含3位数。"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> (lst-&gt;head() &gt;= <span class="number">0</span>) ?</div><div class="line">      Reverse(Cons(<span class="number">0</span>, lst)) :</div><div class="line">      negate(make_number(Cons(- lst-&gt;head(), lst-&gt;tail())));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">add</span><span class="params">(IntList, IntList)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">sub</span><span class="params">(IntList, IntList)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">mul</span><span class="params">(IntList, IntList)</span></span>;</div><div class="line"><span class="function">IntList <span class="title">div</span><span class="params">(IntList, IntList)</span></span>;</div></pre></td></tr></table></figure>
<p>该来的还是来了。</p>
<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>补码加法就是可以为所欲为，只需要位数相同，无视正负数直接加。当位数不同时，提升位数后再加。学过全加器的读者应该能看出<code>add(carry(x-&gt;tail(), new_carry)</code>是多么亲切。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">add</span><span class="params">(IntList x, IntList y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">auto</span> x_len&#123;Length(x)&#125;;</div><div class="line">  <span class="keyword">auto</span> y_len&#123;Length(y)&#125;;</div><div class="line">  <span class="keyword">if</span> (x_len != y_len) &#123;</div><div class="line">    <span class="keyword">auto</span> higher_digits_length = x_len &gt; y_len ? x_len : y_len;</div><div class="line">    <span class="keyword">return</span> add(raise_digits(x, higher_digits_length),</div><div class="line">               raise_digits(y, higher_digits_length));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x == EmptyIntList &amp;&amp; y == EmptyIntList) &#123;</div><div class="line">    <span class="keyword">return</span> EmptyIntList;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">auto</span> neW&#123;x-&gt;head() + y-&gt;head()&#125;;</div><div class="line">    <span class="keyword">auto</span> new_last_digit&#123;calc_remain(neW)&#125;;</div><div class="line">    <span class="keyword">auto</span> new_carry&#123;calc_carry(neW)&#125;;</div><div class="line">    <span class="keyword">return</span> Cons(new_last_digit, add(carry(x-&gt;tail(), new_carry), y-&gt;tail()));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>传说中的开挂来了，不多说。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">sub</span><span class="params">(IntList x, IntList y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> add(x, negate(y));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>先实现一位乘以多位，接着实现多位乘以多位。计算过程和手动乘法差不多，注意到一位乘以多位可以直接用<code>Map</code>，多位乘以多位用到了<code>Fold</code>配合左移。<br>有读者可能会问，这不是补码吗，为什么这里感觉像是直接原码乘。是的，这里实际上采用的是补码一位乘的校正法，是我从华工编写的《计算机组成原理与汇编语言》里面找来的。最后还需要看情况补上一个余项。至于这个余项怎么算出来，读者可以自己翻书（笔者数学不好实在是搞不懂）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">mul</span><span class="params">(IntList x, IntList y)</span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">  <span class="keyword">auto</span> mul_digit_by_all_digits = [](<span class="keyword">int</span> x, IntList xs) &#123;</div><div class="line">      <span class="keyword">return</span> PoorMap([=](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> y * x; &#125;, xs);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> mul_digits_by_all_digits = [&amp;mul_digit_by_all_digits](IntList y, IntList x) &#123;</div><div class="line">      <span class="keyword">return</span> FoldRight([=, &amp;mul_digit_by_all_digits](<span class="keyword">int</span> term, IntList xs) &#123;</div><div class="line">          <span class="keyword">return</span> add(mul_digit_by_all_digits(term, y),</div><div class="line">                     shift_left(xs, <span class="number">1</span>));</div><div class="line">      &#125;, make_number(toList(&#123;<span class="number">0</span>&#125;)), x);</div><div class="line">    &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">auto</span> new_digits_length&#123;Length(x) + Length(y) - <span class="number">1</span>&#125;;</div><div class="line">  <span class="keyword">auto</span> pre_mul = [=](IntList x, IntList y) &#123; </div><div class="line">      <span class="keyword">return</span> mul_digits_by_all_digits( raise_digits(x, new_digits_length), y);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> remain_term = [=](IntList t1, IntList t2) &#123;</div><div class="line">      <span class="keyword">return</span> !(is_negative(t2)) ?</div><div class="line">        make_number(toList(&#123;<span class="number">0</span>&#125;)) :</div><div class="line">        negate( shift_left( raise_digits(t1, new_digits_length),</div><div class="line">                            Length(t2)));</div><div class="line">    &#125;;</div><div class="line">  <span class="comment">// 传说中神奇的余项</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> add(pre_mul(x, y), remain_term(x, y));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>到了除法，我已经越来越懒于找更精妙的算法了。全部转成正数，直接仿照人工手动除法，最后再调整符号。<br><code>quo_prime</code>和<code>rem_prime</code>两个函数用于最初级的除法形式：被除数减除数，重复减直至负数，减的次数即为商。<br>当然不可能真的这样来计算商，我们可以先通过<code>calc_digits</code>计算商的位数，然后模仿人工除法，把除数左移，然后再利用<code>quo_prime</code>和<code>rem_prime</code>一位一位算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">div</span><span class="params">(IntList x, IntList y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (Length(Filter([](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x != <span class="number">0</span>; &#125;, y)) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"###### 除零错误。"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(IntList, IntList)&gt; quo_prime = </div><div class="line">  [&amp;quo_prime](IntList t1, IntList t2) &#123;</div><div class="line">    <span class="keyword">auto</span> remain&#123;sub(t1, t2)&#125;;</div><div class="line">    <span class="keyword">return</span> is_negative(remain) ? </div><div class="line">      <span class="number">0</span> : (<span class="number">1</span> + quo_prime(remain, t2));</div><div class="line">  &#125;;</div><div class="line">  <span class="built_in">std</span>::function&lt;IntList(IntList, IntList)&gt; rem_prime = </div><div class="line">  [&amp;rem_prime](IntList t1, IntList t2) &#123;</div><div class="line">    <span class="keyword">auto</span> remain&#123;sub(t1, t2)&#125;;</div><div class="line">    <span class="keyword">return</span> is_negative(remain) ?</div><div class="line">      add(remain, t2) : rem_prime(remain, t2);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(IntList, IntList)&gt; calc_digits = </div><div class="line">  [&amp;calc_digits](IntList t1, IntList t2) &#123;</div><div class="line">    <span class="keyword">return</span> is_negative(sub(t1, t2))?</div><div class="line">      <span class="number">0</span> : (<span class="number">1</span> + calc_digits(t1, shift_left(t2, <span class="number">1</span>)));</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> div_posi = [&amp;calc_digits, &amp;quo_prime, &amp;rem_prime](IntList t1, IntList t2) &#123;</div><div class="line">    <span class="keyword">auto</span> raised_t2 = raise_digits(t2, Length(t1));</div><div class="line">    <span class="keyword">auto</span> digits_length = calc_digits(t1, raised_t2);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> result = make_number(toList(&#123;<span class="number">0</span>&#125;));</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> dividend = t1</div><div class="line">        , divisor = shift_left(raised_t2, digits_length - <span class="number">1</span>)</div><div class="line">        ; digits_length != <span class="number">0</span></div><div class="line">        ; digits_length--)</div><div class="line">        &#123;</div><div class="line">          result = Cons(quo_prime(dividend, divisor), result);</div><div class="line">          dividend = rem_prime(dividend, divisor);</div><div class="line">          divisor = shift_right(divisor, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (is_negative(x) &amp;&amp; is_negative(y)) &#123;</div><div class="line">    <span class="keyword">return</span> div_posi(negate(x), negate(y));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is_negative(x)) &#123;</div><div class="line">    <span class="keyword">return</span> negate(div_posi(negate(x), y));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is_negative(y)) &#123;</div><div class="line">    <span class="keyword">return</span> negate(div_posi(x, negate(y)));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> div_posi(x, y);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，所有核心代码已经交代完毕，剩余的就是些交互代码了。交互代码可以放松对函数式的执着，毕竟全是在跟副作用打交道！</p>
<hr>
<h1 id="交互代码"><a href="#交互代码" class="headerlink" title="交互代码"></a>交互代码</h1><p>最后再来实现一个REPL（Read–Eval–Print Loop）。</p>
<h2 id="读取（Read）"><a href="#读取（Read）" class="headerlink" title="读取（Read）"></a>读取（Read）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">Parser</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> delimiter&#123;<span class="string">","</span>&#125;;</div><div class="line"></div><div class="line">  IntList result&#123;EmptyIntList&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> pos&#123;<span class="number">0</span>&#125;;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> token;</div><div class="line">  <span class="keyword">while</span> ((pos = s.find(delimiter)) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</div><div class="line">      token = s.substr(<span class="number">0</span>, pos);</div><div class="line">      result = Cons(stoi(token), result);</div><div class="line">      s.erase(<span class="number">0</span>, pos + delimiter.length());</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> Reverse(Cons(stoi(s), result));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="求值（Eval）"><a href="#求值（Eval）" class="headerlink" title="求值（Eval）"></a>求值（Eval）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntList <span class="title">Eval</span><span class="params">(<span class="keyword">char</span> op, IntList x, IntList y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> add(x, y); <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> sub(x, y); <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> mul(x, y); <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> div(x, y); <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> EmptyIntList; <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="打印（Print）"><a href="#打印（Print）" class="headerlink" title="打印（Print）"></a>打印（Print）</h2><p>打印函数是整个程序中第二长的函数，可见为了用户体验，程序员付出了多少汗水。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyPrint</span><span class="params">(<span class="keyword">char</span> op, IntList left, IntList right, IntList result)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">auto</span> format_num = [](IntList n) -&gt; IntList &#123;</div><div class="line">    <span class="keyword">auto</span> remove_zero = [](IntList n) -&gt; IntList &#123;</div><div class="line">      <span class="keyword">auto</span> a = n;</div><div class="line">      <span class="keyword">for</span> (</div><div class="line">          ; (a-&gt;head() == <span class="number">0</span>) &amp;&amp; (a-&gt;tail() != EmptyIntList)</div><div class="line">          ; a = a-&gt;tail()</div><div class="line">      ) &#123;&#125;</div><div class="line">      <span class="keyword">return</span> a;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span> (is_negative(n)) &#123;</div><div class="line">      <span class="keyword">auto</span> posi = remove_zero(Reverse(negate(n)));</div><div class="line">      <span class="keyword">return</span> Cons(- posi-&gt;head(), posi-&gt;tail());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> remove_zero(Reverse(n));</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">auto</span> l = format_num(left);</div><div class="line">  <span class="keyword">auto</span> r = format_num(right);</div><div class="line">  <span class="keyword">auto</span> res = format_num(result);</div><div class="line">  <span class="keyword">auto</span> len = <span class="built_in">std</span>::max(&#123;Length(l), Length(r), Length(res)&#125;);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> print_num = [](IntList n, <span class="keyword">size_t</span> len) -&gt; <span class="keyword">void</span> &#123;</div><div class="line">    <span class="keyword">auto</span> print_digit = [](<span class="keyword">int</span> n, <span class="keyword">size_t</span> width) -&gt; <span class="keyword">void</span> &#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'0'</span>) &lt;&lt; <span class="built_in">std</span>::setw(width) &lt;&lt; n;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">' '</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">4</span> * (len - Length(n)) + <span class="number">1</span>) &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">' '</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">4</span>) &lt;&lt; n-&gt;head();</div><div class="line">    <span class="keyword">while</span> (n-&gt;tail() != EmptyIntList) &#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">      n = n-&gt;tail();</div><div class="line">      print_digit(n-&gt;head(), <span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">" "</span>;  </div><div class="line">  print_num(l, len);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; op;</div><div class="line">  print_num(r, len);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'-'</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">4</span> * (len + <span class="number">1</span>)) &lt;&lt; <span class="string">' '</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">  print_num(res, len);</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ONE-LOOP"><a href="#ONE-LOOP" class="headerlink" title="ONE LOOP"></a>ONE LOOP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Engine</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n请输入运算符(+ - * /)："</span>;</div><div class="line">  <span class="keyword">char</span> op;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> junk;</div><div class="line">  <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, junk, <span class="string">'\n'</span>);</div><div class="line">  <span class="keyword">if</span> (op != <span class="string">'+'</span> &amp;&amp; op != <span class="string">'-'</span> &amp;&amp; op != <span class="string">'*'</span> &amp;&amp; op != <span class="string">'/'</span> ) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"###### 操作符解析错误：应为 + 或 - 或 * 或 /。"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入第一个操作数 (示例：-123, 456, 789 )："</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s1&#123;<span class="string">""</span>&#125;;</div><div class="line">  <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, s1, <span class="string">'\n'</span>);</div><div class="line">  <span class="keyword">auto</span> n1 = make_number(Parser(s1));</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入第二个操作数 (示例：-123, 456, 789 )："</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s2&#123;<span class="string">""</span>&#125;;</div><div class="line">  <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, s2, <span class="string">'\n'</span>);  </div><div class="line">  <span class="keyword">auto</span> n2 = make_number(Parser(s2));</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (Length(n1) &lt;= <span class="number">0</span> || Length(n2) &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"###### 操作数解析错误，格式应为：-123, 456, 789"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> res = Eval(op, n1, n2);</div><div class="line">  PrettyPrint(op, n1, n2, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="REPL-以及错误处理"><a href="#REPL-以及错误处理" class="headerlink" title="REPL 以及错误处理"></a>REPL 以及错误处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Engine();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::runtime_error err) &#123;</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n继续输入？请键入 y 或 n 进行确认："</span>;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="keyword">if</span> (!(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c) || c == <span class="string">'n'</span>) <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>作业一到此为止，作业二更有意思，让我们拭目以待。<br>完整代码：<a href="https://github.com/zhongzc/C-/blob/master/longnum.cpp" target="_blank" rel="external">https://github.com/zhongzc/C-/blob/master/longnum.cpp</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既已有基础材料，撸起袖子做作业。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
      <category term="编程" scheme="http://gaufoo.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/tags/C/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LISP" scheme="http://gaufoo.com/tags/LISP/"/>
    
  </entry>
  
  <entry>
    <title>用C++写出伪LISP代码（一）</title>
    <link href="http://gaufoo.com/cppnlisp1/"/>
    <id>http://gaufoo.com/cppnlisp1/</id>
    <published>2018-03-03T08:48:23.000Z</published>
    <updated>2018-03-04T04:16:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>LISP赐予我力量。</p>
<a id="more"></a>
<hr>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>当时在学《SICP》的时候，突发奇想，看用Scheme(LISP方言的一种)来写C++寒假作业是什么效果。不出意料，实在是太好写了。有了函数式的“我手写我心”加成，短短几十行就把C++寒假作业给搞定了。</p>
<p>既然作业已经完成了，再重新用C++的命令式思路来做，显然太浪费精力和时间。于是萌生出了这么一个想法：何不尝试让C++去适应我的思路，让我写出函数式风格的C++作业呢？</p>
<p>要完成这个工作，首先要模仿LISP简单的结构和功能，本文就是用来解决这个问题。</p>
<hr>
<h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><p>众所周知，LISP这个名字其实是来自于 “LISt Processor” —— “ list 处理器”。所谓的<code>list</code>，是如下的这么一个东西：</p>
<p><img src="/images/180303/photo_2018-03-03_17-53-22.jpg"></p>
<p>前一个盒子连着后一个盒子，第一个盒子有箭头指着，最后一个盒子什么都不指，用斜线填充。</p>
<p>用C++来表达这样的结构是很轻松的事情，每个盒子(<code>Node</code>)包含元素部分，类型为<code>A</code>(<code>Arbitrary</code>)，还有箭头部分，类型为<code>std::shared_ptr&lt;A&gt;</code> (注：<code>std::shared_ptr</code>可以使我们从内存管理的泥潭中抽身而出)。可以通过调用内部的<code>head</code>、<code>tail</code>函数来获取该元素，以及箭头。代码如下：</p>
<p>(*注：以下所有C++代码均采用C++14标准)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNode</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MyNode(T a, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyNode&gt; b) : n(a), next(b)&#123;&#125;;</div><div class="line"></div><div class="line">  <span class="function">T <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyNode&gt; tail() &#123; <span class="keyword">return</span> next; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  T n;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyNode&gt; next;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>初步的结构有了，但请注意到，<code>list</code>是一种递归的结构，我取出某个<code>list</code>的<code>tail</code>(箭头)，它仍然是一个<code>list</code>，直到最后代表<code>list</code>完结的斜线。</p>
<p>所以，在这里我干脆把所有箭头都取相同的名字，叫做<code>Mylist</code>，给最后的斜线也取个名字，叫做<code>EmptyList</code>，规定<code>EmptyList</code>也是一个<code>list</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> MyList = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyNode&lt;T&gt;&gt;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; EmptyList = <span class="literal">nullptr</span>;</div></pre></td></tr></table></figure>
<hr>
<h1 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h1><h2 id="构造-LIST"><a href="#构造-LIST" class="headerlink" title="构造 LIST"></a>构造 LIST</h2><p>上面说过，<code>list</code>是一种递归的结构，所以构造<code>list</code>的方法很简单：给定一个元素<code>x</code>，再一个<code>list</code>，就可以构造一个新的<code>list</code>。这个新<code>list</code>的<code>head</code>是<code>x</code>，<code>tail</code>是旧<code>list</code>，相当于旧<code>list</code>往最前面再长了一个盒子。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * 构造List的基础函数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; Cons(T x, MyList&lt;T&gt; xs)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;MyNode&lt;T&gt;&gt;(x, xs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// auto list3 = Cons(3, EmptyList&lt;int&gt;); </span></div><div class="line"><span class="comment">// =&gt; (3)</span></div><div class="line"><span class="comment">// auto list23 = Cons(2, list3); </span></div><div class="line"><span class="comment">// =&gt; (2, 3)</span></div><div class="line"><span class="comment">// auto list123 = Cons(1, list23); </span></div><div class="line"><span class="comment">// =&gt; (1, 2, 3)</span></div></pre></td></tr></table></figure></p>
<p>每次都从斜线开始一个个盒子地构造<code>list</code>确实有点辛苦，所以我这里写了一个语法糖，让自己可以以轻松又易读的方式构造<code>list</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * 构造List的语法糖</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; toList(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; &amp;il)</div><div class="line">&#123;</div><div class="line">  MyList&lt;T&gt; res = EmptyList&lt;T&gt;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::rbegin(il); it != <span class="built_in">std</span>::rend(il); ++it)</div><div class="line">    res = Cons(*it, res);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// auto list123_ = Cons(1, Cons(2, Cons(3, EmtpyList&lt;int&gt;))); </span></div><div class="line"><span class="comment">// =&gt; (1, 2, 3)</span></div><div class="line"><span class="comment">// auto list123__ = toList(&#123;1, 2, 3&#125;); </span></div><div class="line"><span class="comment">// =&gt; (1, 2, 3)</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="左右折叠函数"><a href="#左右折叠函数" class="headerlink" title="左右折叠函数"></a>左右折叠函数</h2><p>由于函数式语言里并没有常规命令式语言里面的循环语句，使得函数式语言的程序员们通常会采用递归式对<code>list</code>进行遍历操作。而遍历操作又如此地常见，于是有人抽象出了最常见的两种遍历方式，一种是<code>fold left</code>，一种是<code>fold right</code>。它们可以让程序员不必显式地写出递归式，只需要提供：</p>
<ul>
<li>对 <code>单个元素</code> 和 <code>已成功处理的结果</code> 之间操作的函数。</li>
<li>初始结果。</li>
<li>待处理<code>list</code>。</li>
</ul>
<p>便可以通过折叠(fold)函数将<code>list</code>折叠成期望的结构。</p>
<p>例如求和操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> lst = toList(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> a = FoldLeft([](<span class="keyword">int</span> res, <span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x + res; &#125;, <span class="number">0</span>, lst);</div><div class="line"><span class="comment">// a = 6</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> b = FoldRight([](<span class="keyword">int</span> x, <span class="keyword">int</span> res) &#123; <span class="keyword">return</span> x + res; &#125;, <span class="number">0</span>, lst);</div><div class="line"><span class="comment">// b = 6</span></div></pre></td></tr></table></figure></p>
<p>对于求和操作，<code>fold left</code>和<code>fold right</code>都能求出结果，但求值的方式是有所不同：他们的求值结构和顺序是不同的。这里不详细解释他们之间的不同之处，有兴趣可以查阅维基百科：<a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function" target="_blank" rel="external">https://en.wikipedia.org/wiki/Fold_(higher-order_function</a>)</p>
<p>将左右折叠写成C++的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * 左右折叠函数</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Z, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">Z <span class="title">FoldRight</span><span class="params">(F fn, Z zero, MyList&lt;T&gt; xs)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (xs == EmptyList&lt;T&gt;)</div><div class="line">    <span class="keyword">return</span> zero;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> fn(xs-&gt;head(), FoldRight(fn, zero, xs-&gt;tail()));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> Z, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">Z <span class="title">FoldLeft</span><span class="params">(F fn, Z zero, MyList&lt;T&gt; xs)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (xs == EmptyList&lt;T&gt;)</div><div class="line">    <span class="keyword">return</span> zero;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> FoldLeft(fn, fn(zero, xs-&gt;head()), xs-&gt;tail());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出他们实际上都是递归式。</p>
<hr>
<h2 id="翻转-list"><a href="#翻转-list" class="headerlink" title="翻转 list"></a>翻转 list</h2><p>由于上面已经实现了左右折叠函数，在这里可以直接现用了，因为翻转<code>list</code>也不过是个遍历操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * 反转</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; Reverse(MyList&lt;T&gt; xs)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> FoldLeft([](MyList&lt;T&gt; xs, T x) -&gt; MyList&lt;T&gt; &#123; <span class="keyword">return</span> Cons&lt;T&gt;(x, xs); &#125; , </div><div class="line">                  EmptyList&lt;T&gt;, xs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信读者已经看出了函数式语句是何等的简洁了，我上面所实现的函数全都不过寥寥几行，却已经完整表达了我所期望的操作。</p>
<hr>
<h2 id="list-长度"><a href="#list-长度" class="headerlink" title="list 长度"></a>list 长度</h2><p>不出意外，一样是可以通过<code>fold</code>解决。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * Length</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">size_t</span> Length(MyList&lt;T&gt; xs)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> FoldLeft( [](<span class="keyword">size_t</span> x, T rest) &#123; <span class="keyword">return</span> (x + <span class="number">1</span>); &#125;,</div><div class="line">                   <span class="number">0</span>, xs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="Map-函数"><a href="#Map-函数" class="headerlink" title="Map 函数"></a>Map 函数</h2><p>这里的<code>Map</code>和<code>hash table</code>所表达的<code>Map</code>含义不同。这里只是指：提供一个将<code>list</code>元素映射到另外一个元素的函数，通过遍历<code>list</code>的每个元素，将原有的<code>list</code>映射到另外一个相同长度的<code>list</code>。</p>
<p><code>fold</code>函数再次出场：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * Map</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</div><div class="line">MyList&lt;T&gt; PoorMap(F fn, MyList&lt;T&gt; xs)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> FoldRight([&amp;fn](T x, MyList&lt;T&gt; xs) -&gt; MyList&lt;T&gt; &#123; <span class="keyword">return</span> Cons&lt;T&gt;(fn(x), xs); &#125;,</div><div class="line">                   EmptyList&lt;T&gt;, xs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要解释的是，真正的<code>Map</code>函数是可以将一种类型映射到另外一种类型的，这里只能是相同类型之间的映射，所以我称为<code>PoorMap</code>。原因是，以我的能力，要写可以映射到另外一种类型的<code>Map</code>，用户代码将变得丑陋。不得已，我牺牲了功能完备性，保留了简洁性。用户代码若需要映射到另外一种类型时，我将临时使用<code>for</code>循环代替。</p>
<hr>
<h2 id="过滤器函数"><a href="#过滤器函数" class="headerlink" title="过滤器函数"></a>过滤器函数</h2><p>提供一个判断条件，和一个<code>list</code>，可以将不符合条件的元素去除。</p>
<p><code>fold</code>之舞：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * Filter</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; Filter(F fn, MyList&lt;T&gt; xs)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> FoldRight([&amp;fn](T x, MyList&lt;T&gt; xs) -&gt; MyList&lt;T&gt; &#123; <span class="keyword">return</span> (fn(x) ? Cons&lt;T&gt;(x, xs) : xs); &#125;,</div><div class="line">                   EmptyList&lt;T&gt;, xs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="取list前n个元素，构成新list"><a href="#取list前n个元素，构成新list" class="headerlink" title="取list前n个元素，构成新list"></a>取list前n个元素，构成新list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * list-head</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; ListHead(MyList&lt;T&gt; xs, <span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> ( n == <span class="number">0</span> ) ? EmptyList&lt;T&gt; : Cons(xs-&gt;head(), ListHead(xs-&gt;tail(), n - <span class="number">1</span>)) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="丢弃list前n个元素，构成新list"><a href="#丢弃list前n个元素，构成新list" class="headerlink" title="丢弃list前n个元素，构成新list"></a>丢弃list前n个元素，构成新list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * list-tail</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">MyList&lt;T&gt; ListTail(MyList&lt;T&gt; xs, <span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> ( n == <span class="number">0</span> ) ? xs : ListTail(xs-&gt;tail(), n - <span class="number">1</span>) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="list-里是否存在符合条件的元素"><a href="#list-里是否存在符合条件的元素" class="headerlink" title="list 里是否存在符合条件的元素"></a>list 里是否存在符合条件的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// * any</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Any</span><span class="params">(F pred, MyList&lt;T&gt; lst)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> FoldLeft( [&amp;pred](<span class="keyword">bool</span> x, T rest) &#123; <span class="keyword">return</span> pred(rest) || x; &#125;, </div><div class="line">                   <span class="literal">false</span>, lst);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>基础结构和功能已经构造完毕，下面将用来……完成作业。<br>完整代码：<a href="https://github.com/zhongzc/C-/blob/master/mylist.h" target="_blank" rel="external">https://github.com/zhongzc/C-/blob/master/mylist.h</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LISP赐予我力量。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
      <category term="编程" scheme="http://gaufoo.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/tags/C/"/>
    
      <category term="函数式编程" scheme="http://gaufoo.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="LISP" scheme="http://gaufoo.com/tags/LISP/"/>
    
  </entry>
  
  <entry>
    <title>中缀表达式转化前后缀引发的思考</title>
    <link href="http://gaufoo.com/ni_to_pre_post/"/>
    <id>http://gaufoo.com/ni_to_pre_post/</id>
    <published>2018-01-02T06:22:22.000Z</published>
    <updated>2018-01-02T02:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>纠结星人的胜利。</p>
<a id="more"></a>
<hr>
<h1 id="平凡栈实现"><a href="#平凡栈实现" class="headerlink" title="平凡栈实现"></a>平凡栈实现</h1><p>一谈起中缀表达式转前后缀表达式，网上的解决办法中，有一大半是用栈实现，我称之为平凡实现。因为这种方法总让我感觉是在头痛医头、脚痛医脚，拓展性不大。下面来看看。</p>
<hr>
<h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>请原谅我很难把道理讲透，只能说说做法。大体上来看就是让操作符入栈，通过比较读取到的操作符和栈顶操作符优先级，进行入栈和出栈。</p>
<ol>
<li>遇到操作数直接输出</li>
<li>遇到<strong>左</strong>括号，<strong>左</strong>括号入栈</li>
<li>遇到<strong>右</strong>括号，将pop到<strong>左</strong>括号为止</li>
<li>遇到操作符，把<strong>小于等于</strong>它优先级的操作符都出栈，直到<strong>左</strong>括号或者栈<strong>空</strong>，最后让它入栈</li>
<li>读取完表达式，将栈全部pop</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">^</div><div class="line">output: 1        </div><div class="line">stack:</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4     </div><div class="line">  ^</div><div class="line">output: 1       </div><div class="line">stack: -</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">    ^     </div><div class="line">// 左括号入栈</div><div class="line">output: 1</div><div class="line">stack: - (</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">      ^</div><div class="line">output: 1 3      </div><div class="line">stack: - (</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">        ^</div><div class="line">output: 1 3      </div><div class="line">stack: - ( *</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">          ^</div><div class="line">output: 1 3 2  </div><div class="line">stack: - ( *</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">            ^</div><div class="line">// 栈顶是*，-优先级比它小，*输出，-入栈</div><div class="line">output: 1 3 2 *     </div><div class="line">stack: - ( -</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">              ^</div><div class="line">output: 1 3 2 * 5     </div><div class="line">stack: - ( -</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">                ^</div><div class="line">// 遇到右括号，pop到左括号</div><div class="line">output: 1 3 2 * 5 -    </div><div class="line">stack: -</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">                  ^</div><div class="line">output: 1 3 2 * 5 - </div><div class="line">stack: - *</div><div class="line"></div><div class="line">1 - ( 3 * 2 - 5 ) * 4</div><div class="line">                    ^</div><div class="line">output: 1 3 2 * 5 - 4</div><div class="line">stack: - *</div><div class="line"></div><div class="line"></div><div class="line">// 最后全部pop</div><div class="line">output: 1 3 2 * 5 - 4 * -</div><div class="line">stack:</div></pre></td></tr></table></figure>
<h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><p>数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> OP_TYPE &#123; OP_NUM, OP_SYMBOL, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_LBAC, OP_RBAC, &#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    OP_TYPE _type;</div><div class="line">    <span class="keyword">int</span> _value;</div><div class="line"></div><div class="line">    Token(<span class="keyword">int</span> v) : _type(OP_NUM), _value(v) &#123;&#125;</div><div class="line">    Token(<span class="keyword">char</span> c) : _type(OP_SYMBOL), _value(CharToOp(c)) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>实现代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NiToPost</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Token&gt; &amp;nifix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Token&gt; &amp;post)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Token&gt; stk;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : nifix)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (i._type == OP_NUM)</div><div class="line">        &#123;</div><div class="line">            post.push_back(i);</div><div class="line">        &#125;   <span class="comment">// 操作数直接输出</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">auto</span> iv = i._value;</div><div class="line">            <span class="keyword">if</span> (iv == OP_LBAC)</div><div class="line">            &#123;</div><div class="line">                stk.push(i);</div><div class="line">            &#125;   <span class="comment">// 左括号直接入栈</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (iv == OP_RBAC)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (stk.top()._value != OP_LBAC)</div><div class="line">                &#123;</div><div class="line">                    post.push_back(stk.top());</div><div class="line">                    stk.pop();</div><div class="line">                &#125;</div><div class="line">                stk.pop();</div><div class="line">            &#125;   <span class="comment">// 右括号，pop到左括号</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top()._value != OP_LBAC &amp;&amp; CalcPriority(i) &lt;= CalcPriority(stk.top()))</div><div class="line">                &#123;</div><div class="line">                    post.push_back(stk.top());</div><div class="line">                    stk.pop();</div><div class="line">                &#125;</div><div class="line">                stk.push(i);</div><div class="line">            &#125;   <span class="comment">// 遇到操作符，把小于等于它优先级的操作符都出栈，直到左括号或者栈空，最后让它入栈</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!stk.empty())</div><div class="line">    &#123;</div><div class="line">        post.push_back(stk.top());</div><div class="line">        stk.pop();</div><div class="line">    &#125;   <span class="comment">// 读取完表达式，将栈全部pop</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="中缀表达式转前缀表达式"><a href="#中缀表达式转前缀表达式" class="headerlink" title="中缀表达式转前缀表达式"></a>中缀表达式转前缀表达式</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>和转后缀很接近，但是稍麻烦些，需要从后往前读取，最后再翻转过来。而且优先级的比较和转后缀也有所不同，转后缀是小于等于，这里是小于。</p>
<ol>
<li>从后向前读取表达式</li>
<li>遇到操作数直接输出</li>
<li>遇到<strong>右</strong>括号，<strong>右</strong>括号入栈</li>
<li>遇到<strong>左</strong>括号，将pop到<strong>右</strong>括号为止</li>
<li>遇到操作符，把<strong>小于</strong>它优先级的操作符都出栈，直到<strong>右</strong>括号或者栈<strong>空</strong>，最后让它入栈</li>
<li>读取完表达式，将栈全部pop</li>
<li>逆序输出</li>
</ol>
<h3 id="主要代码-1"><a href="#主要代码-1" class="headerlink" title="主要代码"></a>主要代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NiToPre</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Token&gt; &amp;nifix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Token&gt; &amp;pre)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Token&gt; stk;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = nifix.rbegin(); it != nifix.rend(); ++it)</div><div class="line">    <span class="comment">// 从后往前读取</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> i = *it;</div><div class="line">        <span class="keyword">if</span> (i._type == OP_NUM)</div><div class="line">        &#123;</div><div class="line">            pre.push_back(i);</div><div class="line">        &#125;   <span class="comment">// 操作数直接输出</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">auto</span> iv = i._value;</div><div class="line">            <span class="keyword">if</span> (iv == OP_RBAC)</div><div class="line">            &#123;</div><div class="line">                stk.push(i);</div><div class="line">            &#125;   <span class="comment">// 右括号直接入栈</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (iv == OP_LBAC)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (stk.top()._value != OP_RBAC)</div><div class="line">                &#123;</div><div class="line">                    pre.push_back(stk.top());</div><div class="line">                    stk.pop();</div><div class="line">                &#125;</div><div class="line">                stk.pop();</div><div class="line">            &#125;   <span class="comment">// 左括号，pop到右括号</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top()._value != OP_RBAC &amp;&amp; CalcPriority(i) &lt; CalcPriority(stk.top()))</div><div class="line">                &#123;</div><div class="line">                    pre.push_back(stk.top());</div><div class="line">                    stk.pop();</div><div class="line">                &#125;</div><div class="line">                stk.push(i);</div><div class="line">            &#125;   <span class="comment">// 遇到操作符，把小于它优先级的操作符都出栈，直到左括号或者栈空，最后让它入栈</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!stk.empty())</div><div class="line">    &#123;</div><div class="line">        pre.push_back(stk.top());</div><div class="line">        stk.pop();</div><div class="line">    &#125;   <span class="comment">// 读取完表达式，将栈全部pop</span></div><div class="line"></div><div class="line">    reverse(pre.begin(), pre.end());    <span class="comment">// 最后逆序输出</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/prepost/0.png" alt="0"></p>
<hr>
<h1 id="平凡二叉树实现"><a href="#平凡二叉树实现" class="headerlink" title="平凡二叉树实现"></a>平凡二叉树实现</h1><p>如果构造一棵语法树，那就想输出什么缀就输出什么缀，无非就是前序遍历和后序遍历。<br>像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTrav</span><span class="params">(Node *&amp;Node)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (Node-&gt;left == <span class="literal">nullptr</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Node-&gt;token._value &lt;&lt; <span class="string">' '</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; OpToChar(Node-&gt;token._value) &lt;&lt; <span class="string">' '</span>;</div><div class="line">        PreTrav(Node-&gt;left);</div><div class="line">        PreTrav(Node-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTrav</span><span class="params">(Node *&amp;Node)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (Node-&gt;left == <span class="literal">nullptr</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Node-&gt;token._value &lt;&lt; <span class="string">' '</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        PostTrav(Node-&gt;left);</div><div class="line">        PostTrav(Node-&gt;right);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; OpToChar(Node-&gt;token._value) &lt;&lt; <span class="string">' '</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>终端输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">后序遍历：7 6 - 5 4 3 / + + 2 1 * -</div><div class="line">前序遍历：- + - 7 6 + 5 / 4 3 * 2 1</div></pre></td></tr></table></figure></p>
<p>甚至可以画一棵二叉树：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_impl</span><span class="params">(Node *n, <span class="keyword">bool</span> left, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span> &amp;indent)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (n-&gt;right)</div><div class="line">    &#123;</div><div class="line">        output_impl(n-&gt;right, <span class="literal">false</span>, indent + (left ? <span class="string">"|     "</span> : <span class="string">"      "</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; indent;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (left ? <span class="string">'`'</span> : <span class="string">'.'</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- "</span>;</div><div class="line">    <span class="keyword">if</span> (n-&gt;token._type == OP_NUM)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n-&gt;token._value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; OpToChar(n-&gt;token._value) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (n-&gt;left)</div><div class="line">    &#123;</div><div class="line">        output_impl(n-&gt;left, <span class="literal">true</span>, indent + (left ? <span class="string">"      "</span> : <span class="string">"|     "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (root-&gt;right)</div><div class="line">    &#123;</div><div class="line">        output_impl(root-&gt;right, <span class="literal">false</span>, <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root-&gt;token._type == OP_NUM)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;token._value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; OpToChar(root-&gt;token._value) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root-&gt;left)</div><div class="line">    &#123;</div><div class="line">        output_impl(root-&gt;left, <span class="literal">true</span>, <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>终端输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">      .--- 1</div><div class="line">.--- *</div><div class="line">|     `--- 2</div><div class="line">-</div><div class="line">|                 .--- 3</div><div class="line">|           .--- /</div><div class="line">|           |     `--- 4</div><div class="line">|     .--- +</div><div class="line">|     |     `--- 5</div><div class="line">`--- +</div><div class="line">      |     .--- 6</div><div class="line">      `--- -</div><div class="line">            `--- 7</div></pre></td></tr></table></figure></p>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>为什么又叫作平凡实现呢，因为这种实现在构造二叉树的时候，本质上和栈实现没太大差别，还是根据优先级进行入栈出栈。</p>
<h3 id="主要代码-2"><a href="#主要代码-2" class="headerlink" title="主要代码"></a>主要代码</h3><p>数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    Token token;</div><div class="line">    Node *left = <span class="literal">nullptr</span>;</div><div class="line">    Node *right = <span class="literal">nullptr</span>;</div><div class="line">    Node(<span class="keyword">const</span> Token &amp;t) : token(t) &#123;&#125;</div><div class="line">    Node(<span class="keyword">const</span> Token &amp;t, Node *l, Node *r) : token(t), left(l), right(r) &#123;&#125;</div><div class="line">    ~Node()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">delete</span> left;</div><div class="line">        <span class="keyword">delete</span> right;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>实现代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NiToBitree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Token&gt; &amp;nifix, Node *&amp;Tree)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node *&gt; branch;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Token&gt; op;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : nifix)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (i._type == OP_NUM)</div><div class="line">        &#123;</div><div class="line">            branch.push(<span class="keyword">new</span> Node(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">auto</span> iv = i._value;</div><div class="line">            <span class="keyword">if</span> (iv == OP_LBAC)</div><div class="line">            &#123;</div><div class="line">                op.push(i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (iv == OP_RBAC)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (op.top()._value != OP_LBAC)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">auto</span> r = branch.top();</div><div class="line">                    branch.pop();</div><div class="line">                    <span class="keyword">auto</span> l = branch.top();</div><div class="line">                    branch.pop();</div><div class="line">                    branch.push(<span class="keyword">new</span> Node(op.top(), l, r));</div><div class="line">                    op.pop();</div><div class="line">                &#125;</div><div class="line">                op.pop();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span> (!op.empty() &amp;&amp; op.top()._value != OP_LBAC &amp;&amp; CalcPriority(i) &lt;= CalcPriority(op.top()))</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">auto</span> r = branch.top();</div><div class="line">                    branch.pop();</div><div class="line">                    <span class="keyword">auto</span> l = branch.top();</div><div class="line">                    branch.pop();</div><div class="line">                    branch.push(<span class="keyword">new</span> Node(op.top(), l, r));</div><div class="line">                    op.pop();</div><div class="line">                &#125;</div><div class="line">                op.push(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!op.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> r = branch.top();</div><div class="line">        branch.pop();</div><div class="line">        <span class="keyword">auto</span> l = branch.top();</div><div class="line">        branch.pop();</div><div class="line">        branch.push(<span class="keyword">new</span> Node(op.top(), l, r));</div><div class="line">        op.pop();</div><div class="line">    &#125;</div><div class="line">    Tree = branch.top();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="优雅实现之语法分析器"><a href="#优雅实现之语法分析器" class="headerlink" title="优雅实现之语法分析器"></a>优雅实现之语法分析器</h1><p>我实在是不满足平凡实现，觉得它太实在了，老老实实总会遭人欺负的。于是我对着这四则运算表达式圈圈画画，没想到还真看出来了端倪。然后赶紧上搜索引擎看看有没同道中人已经实现过这种思路，果然……轮子哥在八年前，也就是在我还是小学生的时候，就已经实现过了……好吧，下面一起来看看。</p>
<hr>
<h2 id="单位化"><a href="#单位化" class="headerlink" title="单位化"></a>单位化</h2><h3 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h3><p>一个表达式，可以看成是若干个单位通过<code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>连接起来，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 + 2            // 单位：1, 2</div><div class="line">3                // 单位：3</div><div class="line">5 + (4 - 2) * 3  // 单位：5, (4 - 2) * 3</div><div class="line">6 * 4 - 3        // 单位：6 * 4, 3</div></pre></td></tr></table></figure></p>
<p>我们把这种单位抽象出来，取个名字：<strong>Factor</strong>。</p>
<p>因此，表达式可以这样来表示： <code>Exp = Factor (( &#39;+&#39; | &#39;-&#39; ) Factor)*</code>，十分的简洁明了。</p>
<h3 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h3><p>接下来Factor也不难表示，可以看成是若干个单位通过<code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>连接起来，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 * 2       // 单位：1, 2</div><div class="line">(4 - 2) * 3 // 单位：(4 - 2), 3</div><div class="line">5 / 4 * 6   // 单位：5, 4, 6</div></pre></td></tr></table></figure></p>
<p>我们把这种单位抽象出来，取个名字：<strong>Term</strong>。</p>
<p>因此，Factor可以这样来表示：<code>Factor = Term (( &#39;*&#39; | &#39;/&#39; ) Term)*</code></p>
<h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>最后就是最基本的单位Term，通过观察可知Term要么是数字，要么是括号括起来的一个表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">50          --&gt; Term</div><div class="line">(4 - 2)     --&gt; Term</div></pre></td></tr></table></figure></p>
<p>因此Term可以这样来表示：<code>Term = &lt;数字&gt; | &#39;(&#39; Exp &#39;)&#39;</code></p>
<p>我们可以通过上面的关系来构造语法树，可以想象，生成过程真的很像一棵树的生长。</p>
<p>没错！我就是想要这种非常函数式的实现，这种抽象美得让人陶醉。鲁迅先生好像说过：</p>
<blockquote>
<p>Any problem in computer science can be solved with another level of indirection.<br>计算机科学里面，没有什么问题是多加一层抽象不可以解决的。</p>
</blockquote>
<hr>
<h2 id="语法树特点"><a href="#语法树特点" class="headerlink" title="语法树特点"></a>语法树特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">      .--- 1</div><div class="line">.--- *</div><div class="line">|     `--- 2</div><div class="line">-</div><div class="line">|                 .--- 3</div><div class="line">|           .--- /</div><div class="line">|           |     `--- 4</div><div class="line">|     .--- +</div><div class="line">|     |     `--- 5</div><div class="line">`--- +</div><div class="line">      |     .--- 6</div><div class="line">      `--- -</div><div class="line">            `--- 7</div></pre></td></tr></table></figure>
<p>借用上边画出来的语法树，来观察语法树的结构：</p>
<ul>
<li>一个数字表达式的节点一定是一个叶子节点，没有左右孩子节点。</li>
<li>一个二元运算表达式一定有两个孩子节点，因为二元运算符号左右两边必然都要有表达式。这两个叶子节点的类型，是抽象的表达式，既可以是二元运算表达式，也可以是数字表达式。</li>
</ul>
<p>由此可以定义<code>Expression</code>作为基类，派生出<code>NumberExpression</code>类和<code>BinaryExpression</code>类，来表示数字表达式和二元运算表达式。<br><img src="/images/prepost/1.jpg" alt="1"></p>
<blockquote>
<p>注：下面都是用现代C++来实现，区别于轮子哥八年前写的古老C++版。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~Expression() = <span class="keyword">default</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> :</span> <span class="keyword">public</span> Expression</div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> Value;</div><div class="line">    NumberExpression(<span class="keyword">int</span> number) : Value(number) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExpression</span> :</span> <span class="keyword">public</span> Expression</div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; First;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; Second;</div><div class="line">    BinaryOperator Op;</div><div class="line">    BinaryExpression(BinaryOperator theOp, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; theLeft, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; theRight) : Op(theOp), First(theLeft), Second(theRight) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>BinaryOperator</code>枚举类型也要现代一点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryOperator</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    Plus,</div><div class="line">    Minus,</div><div class="line">    Multiply,</div><div class="line">    Divide,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="构造语法树"><a href="#构造语法树" class="headerlink" title="构造语法树"></a>构造语法树</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><h4 id="Is"><a href="#Is" class="headerlink" title="Is"></a>Is</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Is</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream, <span class="keyword">const</span> <span class="keyword">char</span> *Text)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(Text);</div><div class="line">    <span class="comment">/*保存参数*/</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *Read = Stream;</div><div class="line">    <span class="comment">/*过滤空格*/</span></div><div class="line">    <span class="keyword">while</span> (*Read == <span class="string">' '</span>)</div><div class="line">        Read++;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(Read, Text, len) == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        Stream = Read + len;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于判断Stream是不是由Text开头，如果是就将Stream偏移strlen(Text)个字符。</p>
<h4 id="GetNumber"><a href="#GetNumber" class="headerlink" title="GetNumber"></a>GetNumber</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetNumber(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> Result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">bool</span> GotNumber = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *Read = Stream;</div><div class="line">    <span class="keyword">while</span> (*Read == <span class="string">' '</span>)</div><div class="line">        Read++;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">char</span> c = *Read;</div><div class="line">        <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>)</div><div class="line">        &#123;</div><div class="line">            Result = Result * <span class="number">10</span> + (c - <span class="string">'0'</span>);</div><div class="line">            GotNumber = <span class="literal">true</span>;</div><div class="line">            Read++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (GotNumber)</div><div class="line">    &#123;</div><div class="line">        Stream = Read;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;NumberExpression&gt;(Result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> Exception(Stream, <span class="string">"此处需要表达式"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个函数的作用是，按照数字的方式，对Stream进行解析，如果解析成功，就将Stream指针的位置移动到解析完成的最后位置（代码中的Read），然后调用make_shared，构造一个shared_ptr并返回；而如果失败（即一个数字都没找到），则抛出一个异常。跟Is一样，这个函数会过滤掉开头的空格。</p>
</blockquote>
<hr>
<h3 id="辅助异常类"><a href="#辅助异常类" class="headerlink" title="辅助异常类"></a>辅助异常类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Exception</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *Start;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *Error;</div><div class="line">    Exception(<span class="keyword">const</span> <span class="keyword">char</span> *aStart, <span class="keyword">const</span> <span class="keyword">char</span> *aError)</div><div class="line">    &#123;</div><div class="line">        Start = aStart;</div><div class="line">        Error = aError;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetTerm(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetFactor(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetExp(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream);</div></pre></td></tr></table></figure>
<p>三个解析函数，完成语法树的构造。</p>
<h4 id="GetExp"><a href="#GetExp" class="headerlink" title="GetExp"></a>GetExp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetExp(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *Read = Stream;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; Result = GetFactor(Read);</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        BinaryOperator Operator;</div><div class="line">        <span class="keyword">if</span> (Is(Read, <span class="string">"+"</span>))</div><div class="line">        &#123;</div><div class="line">            Operator = BinaryOperator::Plus;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Is(Read, <span class="string">"-"</span>))</div><div class="line">        &#123;</div><div class="line">            Operator = BinaryOperator::Minus;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        Result = <span class="built_in">std</span>::make_shared&lt;BinaryExpression&gt;(Operator, Result, GetFactor(Read));</div><div class="line">    &#125;</div><div class="line">    Stream = Read;</div><div class="line">    <span class="keyword">return</span> Result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成：<code>Exp = Factor (( &#39;+&#39; | &#39;-&#39; ) Factor)*</code><br>构造出来的形状是这样的：<br><img src="/images/prepost/2.jpg" alt="1"></p>
<h4 id="GetFactor"><a href="#GetFactor" class="headerlink" title="GetFactor"></a>GetFactor</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetFactor(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *Read = Stream;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; Result = GetTerm(Read);</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        BinaryOperator Operator;</div><div class="line">        <span class="keyword">if</span> (Is(Read, <span class="string">"*"</span>))</div><div class="line">        &#123;</div><div class="line">            Operator = BinaryOperator::Multiply;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Is(Read, <span class="string">"/"</span>))</div><div class="line">        &#123;</div><div class="line">            Operator = BinaryOperator::Divide;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        Result = <span class="built_in">std</span>::make_shared&lt;BinaryExpression&gt;(Operator, Result, GetTerm(Read));</div><div class="line">    &#125;</div><div class="line">    Stream = Read;</div><div class="line">    <span class="keyword">return</span> Result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成：<code>Factor = Term (( &#39;*&#39; | &#39;/&#39; ) Term)*</code></p>
<h4 id="GetTerm"><a href="#GetTerm" class="headerlink" title="GetTerm"></a>GetTerm</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Expression&gt; GetTerm(<span class="keyword">const</span> <span class="keyword">char</span> *&amp;Stream)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> GetNumber(Stream);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Exception &amp;e)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *Read = Stream;</div><div class="line">        <span class="keyword">if</span> (Is(Read, <span class="string">"("</span>))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">auto</span> Result = GetExp(Read);</div><div class="line">            <span class="keyword">if</span> (Is(Read, <span class="string">")"</span>))</div><div class="line">            &#123;</div><div class="line">                Stream = Read;</div><div class="line">                <span class="keyword">return</span> Result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">throw</span> Exception(Stream, <span class="string">"此处需要右括号"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成：<code>Term = &lt;数字&gt; | &#39;(&#39; Exp &#39;)&#39;</code></p>
<p>好了，这样就搞定啦！虽然代码看起来有点点长，可是思路是十分清晰自然的。我相信用函数式语言来写会短几十倍的，用C++写只是为了照顾大部分人。最后奉上测试代码。</p>
<hr>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">auto</span> a = <span class="string">"75 + 66 * (555-333*444) - 332 * 111"</span>;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> <span class="built_in">exp</span> = GetExp(a);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Exception &amp;e)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.Start &lt;&lt; e.Error &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Do what you want to do</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>完整代码：<a href="https://gist.github.com/zhongzc/3f9cc3024684ab5b0b70729a348c5f6a" target="_blank" rel="external">https://gist.github.com/zhongzc/3f9cc3024684ab5b0b70729a348c5f6a</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纠结星人的胜利。&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="C++11" scheme="http://gaufoo.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>利用C语言缺陷进行缓冲区溢出攻击</title>
    <link href="http://gaufoo.com/overflow/"/>
    <id>http://gaufoo.com/overflow/</id>
    <published>2017-12-30T06:22:22.000Z</published>
    <updated>2017-12-30T06:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>黑客初体验。</p>
<a id="more"></a>
<hr>
<h1 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h1><h2 id="简单栈帧结构"><a href="#简单栈帧结构" class="headerlink" title="简单栈帧结构"></a>简单栈帧结构</h2><p>对栈帧结构最简单的解释就是，用<strong>栈指针(sp, stack pointer)</strong> 和<strong>帧指针(bp, base pointer)</strong> 标识内存头尾，中间部分的内存供函数的代码进行操作。<br><img src="/images/overflow/mmexport1514564834036.jpg" width="400px"></p>
<h2 id="函数执行"><a href="#函数执行" class="headerlink" title="函数执行"></a>函数执行</h2><p>包括代码域和数据域：</p>
<ul>
<li>代码域存放代码，但是是固定的，运行之前就已经确定。</li>
<li>数据域存放临时变量，运行时才开辟出来，采用的是<strong>栈帧结构</strong>。</li>
</ul>
<p>当代码段执行<code>call &lt;func&gt;</code>，程序将跳转到<code>func</code>函数的代码头，执行<code>func</code>函数的代码，并让它自行开辟栈帧。<br><img src="/images/overflow/mmexport1514564847370.jpg" width="400px"></p>
<h2 id="假想栈帧结构"><a href="#假想栈帧结构" class="headerlink" title="假想栈帧结构"></a>假想栈帧结构</h2><p>当<code>func</code>函数执行完，应该回到调用它的原来的函数代码，以及回到原来函数的栈帧。那么该如何实现呢？</p>
<ul>
<li><p>回到原来的栈帧：其中一种假想的思路是，栈指针和帧指针指向的内存分别存放原来的栈指针和帧指针，返回的时候直接替换就行了。<br><img src="/images/overflow/mmexport1514564838433.jpg" width="400px"></p>
</li>
<li><p>回到原来的代码：可以在帧指针的上一处内存存放<code>call &lt;func&gt;</code>的下一句代码的地址，这样返回的时候让帧指针帮下忙，就可以轻松回到原来的代码。<br><img src="/images/overflow/mmexport1514564820384.jpg"></p>
</li>
</ul>
<h2 id="实际结构"><a href="#实际结构" class="headerlink" title="实际结构"></a>实际结构</h2><p>这样假想的栈帧结构其实已经很像真实的栈帧结构了。<br>为了所谓的追求速度，真正的函数栈帧结构其实是连续的，一串连着一串，像这样：<br><img src="/images/overflow/mmexport1514564829598.jpg" width="500px"><br>与假想的栈帧结构相比：</p>
<ul>
<li>不变的是返回地址还是在帧指针之上，帧指针还是指向原来的帧指针。</li>
<li>不同的是栈指针不再需要存放原来的栈指针，因为返回地址之上就是原来栈指针所指的地方。</li>
</ul>
<h2 id="过程汇编代码"><a href="#过程汇编代码" class="headerlink" title="过程汇编代码"></a>过程汇编代码</h2><p>调用函数的经过如下：</p>
<ol>
<li><code>push pc</code> # 返回地址入栈。</li>
<li><code>push bp</code> # 原来的帧指针入栈。</li>
<li><code>mov sp,bp</code> # 让帧指针指向原来的帧指针。</li>
<li><code>sub sp,#(栈帧大小)</code> # 让栈指针往下开辟一个新的栈帧。</li>
</ol>
<p><img src="/images/overflow/mmexport1514564825156.jpg" alt="mmexport1514564825156"></p>
<p>类似的，返回原来函数的经过如下：</p>
<ol>
<li><code>mov bp,sp</code> # 栈指针指向帧指针指向的内存。</li>
<li><code>pop bp</code> # 帧指针指向原来帧指针指向的内存。</li>
<li><code>pop pc</code> # 回到原来函数的代码</li>
</ol>
<p><img src="/images/overflow/mmexport1514564842593.jpg" alt="mmexport1514564842593"></p>
<hr>
<h1 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h1><p>可以想象，如果有办法修改栈帧上的返回地址，无疑可以让程序转向任何我们想转向的地方。但是一般不具备这样的机会，因为变量都是有固定大小的，很难突破变量大小的限制，修改变量以外的内存。<br>偏偏C语言对速度的变态追求和对程序员的信任，给了我们这样的机会：它几乎从不进行边界检查，数组可以越界，<code>gets</code>可以越界，而且越界以后只要不影响程序的运行，连崩溃都不会发生。<br>假如一个函数调用了<code>gets</code>向局部变量写入字符串，我们就可以写入比局部变量所规定大小还要大的字符串，业内称作<strong>注入字符串</strong>，来覆盖掉栈帧上的信息，从而达到修改内存的目的。</p>
<hr>
<h2 id="破坏型注入"><a href="#破坏型注入" class="headerlink" title="破坏型注入"></a>破坏型注入</h2><p>只粗暴地覆盖返回地址。当函数返回时，代码会跳到被覆盖的返回地址，但是栈帧已经乱套了。<br>不过只要跳到的代码不会用到栈帧，而且能很快就结束程序，那么这种溢出攻击无疑是最简单直接的选择。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>《CSAPP》上提供的实验，需要我们将程序跳到一个名叫<code>smoke</code>的函数。</p>
<p>步骤如下：</p>
<ol>
<li>反汇编程序得到汇编代码。</li>
<li>查看调用<code>gets</code>的函数的汇编代码，推测需要覆盖多少字节。</li>
<li>查看<code>smoke</code>函数的代码地址。</li>
<li>编写注入的16进制机器码。</li>
<li>实行覆盖。</li>
</ol>
<hr>
<ul>
<li>反汇编：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> objdump -d ./bufbomb &gt; disas.txt</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查看调用<code>gets</code>的函数：<br>  <img src="/images/overflow/0.png"><br>  将<code>%ebp-0x28</code>赋给<code>%eax</code>令人瞩目，这就是字符串首地址。因此覆盖的字符串应当包含：4位返回地址 + 4位bp + 40(0x28的十进制)位字符。</p>
</li>
<li><p><code>smoke</code>函数首地址：<br>  <img src="/images/overflow/1.png"><br>  得到<code>smoke</code>函数首地址：<code>0x08048c18</code></p>
</li>
<li><p>编写注入的16进制机器码</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00 /* 原字符串大小 */</div><div class="line">00 00 00 00 /* 现bp所指位置，原bp所在位置 */</div><div class="line">18 8c 04 08 /* 覆盖的返回地址 */</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>转成ASCII字符串，此处省略</p>
</li>
<li><p>注入，查看结果<br>  <img src="/images/overflow/3.png"><br>  成功</p>
</li>
</ul>
<hr>
<h2 id="擦屁股型注入"><a href="#擦屁股型注入" class="headerlink" title="擦屁股型注入"></a>擦屁股型注入</h2><p>与破坏型注入相对的是：擦屁股型注入。大意是能让程序正确地返回到原来的函数，并且恢复原来的栈帧。这种注入的要求更高，但是能做到的东西更多，更神不知鬼不觉。<br>这里要讲到汇编语言的一个缺陷：可以允许pc跳到栈段，并把里面的数据当代码执行。因此，只要把注入代码伪装成字符串，让覆盖的返回地址指向注入代码头，就可以让程序执行注入代码。再配合上擦屁股，就可以让作案现场毫无破绽。<br>这就是我花这么大的篇幅去讲解栈帧结构的原因：只要真正理解了栈帧结构，恢复它简直易如反掌。</p>
<p>要点如下：</p>
<ol>
<li>覆盖返回地址时，会覆盖bp所指向的原bp，只要保证它不变，bp就能顺利回到原bp。</li>
<li>跳到注入代码后，sp已经指向原sp了，所以只要在注入代码的最后，把原返回地址push进栈再ret，就和原来的代码如出一辙。</li>
</ol>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>《CSAPP》上提供的实验，需要我们修改向原函数返回的值。<br>要修改返回值，就要修改寄存器，可寄存器不如内存那么好处理，不能直接覆盖，只能通过注入代码的方式修改。而且要想成功返回，就得做好擦屁股的工作。</p>
<p>步骤如下：</p>
<ol>
<li>查看反汇编代码，记录正确的返回地址。</li>
<li>用<code>gdb</code>调试程序，记录原bp和字符串首地址。</li>
<li>编写注入的汇编代码，并利用<code>gcc</code>，<code>objdump</code>工具将其翻译成机器码。</li>
<li>编写注入的16进制机器码。</li>
<li>实行覆盖。</li>
</ol>
<hr>
<ul>
<li><p>查看反汇编代码：<br>  <img src="/images/overflow/2.png"><br>  得到返回地址：<code>0x08048dbe</code></p>
</li>
<li><p>用<code>gdb</code>查看原bp：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> gdb ./bufbomb</span></div><div class="line">  </div><div class="line">(gdb) b getbuf</div><div class="line">(gdb) run -u gaufoo</div><div class="line">(gdb) p /x *(int *)$ebp</div></pre></td></tr></table></figure>
<p>  <img src="/images/overflow/5.png"></p>
<p>  得到原bp：<code>0x55683d20</code></p>
</li>
<li><p>用<code>gdb</code>查看字符串首地址，就把代码注入到那：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> gdb ./bufbomb</span></div><div class="line">  </div><div class="line">(gdb) b getbuf</div><div class="line">(gdb) run -u gaufoo</div><div class="line">(gdb) p /x ($ebp-0x28)</div></pre></td></tr></table></figure>
<p>  <img src="/images/overflow/7.png"></p>
<p>  得到字符串首地址：<code>0x55683cc8</code></p>
</li>
<li><p>编写汇编代码，并译成机器码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// sc.s</div><div class="line">mov $0x4a3e65c1,%eax</div><div class="line">push $0x08048dbe</div><div class="line">ret</div></pre></td></tr></table></figure>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -c sc.s</span></div><div class="line"><span class="meta">$</span><span class="bash"> objdump -d sc.o</span></div></pre></td></tr></table></figure>
<p>  <img src="/images/overflow/6.png"></p>
</li>
<li><p>编写注入的16进制机器码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">b8 c1 65 3e 4a  /* mov $0x4a3e65c1,%eax */</div><div class="line">68 be 8d 04 08  /* push $0x08048dbe */</div><div class="line">c3              /* ret */</div><div class="line">00 00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00</div><div class="line">00 00 00 00 </div><div class="line">20 3d 68 55     /* 现bp所指位置，原bp所在位置 */</div><div class="line">c8 3c 68 55     /* 字符串首地址 */</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>转成ASCII字符串，此处省略</p>
</li>
<li><p>注入，查看结果<br>  <img src="/images/overflow/8.png"><br>  成功</p>
</li>
</ul>
<hr>
<h2 id="反注入原理与抗反注入方法"><a href="#反注入原理与抗反注入方法" class="headerlink" title="反注入原理与抗反注入方法"></a>反注入原理与抗反注入方法</h2><p>gcc编译器反注入的其中一种措施是<strong>栈随机化</strong>，原理是：每次程序运行时在栈最底部随机插上一段不用的内存，让实际使用的栈地址发生变化。它会导致原bp所在位置和字符串首地址不再是固定值，给代码注入带来一定困难。</p>
<p>对抗这种反注入的方法也挺简单的：</p>
<ul>
<li>原bp可以通过现sp计算得到。</li>
<li>虽然不再能得到字符串首地址，但可以大概猜到字符串中间的位置，只要把代码放在最后面，前面全部用空语句填充。当代码转到任何一个空语句，最终都能“滑”到我想执行的注入代码。</li>
</ul>
<h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><p>《CSAPP》上提供的实验，注入5次字符串，每次都需要修改向原函数返回的值，难点在于每次注入时的栈地址都会发生变化，模拟编译器的栈随机化。</p>
<p>步骤如下：</p>
<ol>
<li>查看反汇编代码，记录正确的返回地址。</li>
<li>查看反汇编代码，记录原bp和原sp的距离。</li>
<li>用<code>gdb</code>调试程序，查看5次字符串首地址，记录最接近尾部的值，即最大值，作为猜测出来的栈中间地址。</li>
<li>编写注入的汇编代码，并利用<code>gcc</code>，<code>objdump</code>工具将其翻译成机器码。</li>
<li>编写注入的16进制机器码。</li>
<li>实行覆盖。</li>
</ol>
<hr>
<ul>
<li><p>记录正确的返回地址：<br>  <img src="/images/overflow/9.png"><br>  得到返回地址：<code>0x08048e3a</code></p>
</li>
<li><p>记录原bp和原sp的距离<br>  <img src="/images/overflow/9.png"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">push %ebp</div><div class="line">push %ebx</div><div class="line">sub $0x24,%esp</div></pre></td></tr></table></figure>
<p>  由这三句汇编代码可得距离为：0x28 = 0x24 + 0x4(ebx长度)</p>
</li>
<li><p>查看5次字符串首地址</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gdb ./bufbomb</div><div class="line">  </div><div class="line">(gdb) b getbufn</div><div class="line">(gdb) run -n -u gaufoo</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) disas getbufn</div></pre></td></tr></table></figure>
<p>  <img src="/images/overflow/10.png"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(gdb) p /x $ebp-0x208</div><div class="line">continue</div><div class="line">(gdb) p /x $ebp-0x208</div><div class="line">continue</div><div class="line">(gdb) p /x $ebp-0x208</div><div class="line">continue</div><div class="line">(gdb) p /x $ebp-0x208</div><div class="line">continue</div><div class="line">(gdb) p /x $ebp-0x208</div><div class="line">continue</div></pre></td></tr></table></figure>
<p>  <img src="/images/overflow/11.png"></p>
<p>  得到首地址最大值：<code>0x55683b58</code></p>
</li>
<li><p>编写注入汇编代码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov $0x4a3e65c1,%eax</div><div class="line">lea -0x28(%esp),%ebp</div><div class="line">push $0x08048e3a</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>  <code>gcc</code>+<code>objdump</code>，翻译成机器码：<br>  <img src="/images/overflow/12.png"></p>
</li>
<li><p>编写注入机器码：<br>  首先0x208是字符串缓冲区长度，十进制为520。<br>  因此注入的机器码应为：509个字节空指令 + 15个字节注入代码 + 4个字节跳转地址 = 528个字节，<br>  因为要注入5次，所以后面要加上’\0a’，再复制5次。<br>  <img src="/images/overflow/13.png"></p>
</li>
<li><p>转成ASCII字符串，此处省略</p>
</li>
<li><p>注入，查看结果<br>  <img src="/images/overflow/14.png"><br>  成功</p>
</li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;黑客初体验。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编" scheme="http://gaufoo.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="C" scheme="http://gaufoo.com/tags/C/"/>
    
      <category term="原理" scheme="http://gaufoo.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="汇编" scheme="http://gaufoo.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>听说C语言也可以“泛型”</title>
    <link href="http://gaufoo.com/genericC/"/>
    <id>http://gaufoo.com/genericC/</id>
    <published>2017-12-09T07:02:51.000Z</published>
    <updated>2017-12-09T10:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>都说泛型是C++的一大特性，我大C语言表示不服</p>
<a id="more"></a>
<hr>
<h1 id="再探类型"><a href="#再探类型" class="headerlink" title="再探类型"></a>再探类型</h1><p>C/C++类型由以下各项组成：</p>
<ul>
<li>内存里的’0’、’1’序列</li>
<li>‘0’、’1’串占用的内存大小</li>
<li>作为操作数时如何解释与输出位模式（如cout、printf、强制类型转换）</li>
<li>作为操作数时如何修改位模式（如+、-、*、/）</li>
</ul>
<h1 id="“泛型”原理"><a href="#“泛型”原理" class="headerlink" title="“泛型”原理"></a>“泛型”原理</h1><p>只需要提供内存首地址，类型大小。利用上面提出的前两点，直接操作内存，就能正确实现泛型。而且不需要为每个类型重新生成代码，克服了C++的代码膨胀问题。</p>
<h1 id="热身——swap泛型实现"><a href="#热身——swap泛型实现" class="headerlink" title="热身——swap泛型实现"></a>热身——swap泛型实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">void</span> *vp1, <span class="keyword">void</span> *vp2, <span class="keyword">int</span> size)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">char</span> buffer[size];</div><div class="line">    <span class="built_in">memcpy</span>(buffer, vp1, size);</div><div class="line">    <span class="built_in">memcpy</span>(vp1, vp2, size);</div><div class="line">    <span class="built_in">memcpy</span>(vp2, buffer, size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">double</span> a = <span class="number">2.5</span>;</div><div class="line">    <span class="keyword">double</span> b = <span class="number">4.5</span>;</div><div class="line">    <span class="keyword">int</span> c = <span class="number">100</span>;</div><div class="line">    <span class="keyword">int</span> d = <span class="number">200</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"a = %f, b = %f\nc = %d, d = %d\n"</span>, a, b, c, d);</div><div class="line">    swap(&amp;a, &amp;b, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</div><div class="line">    swap(&amp;c, &amp;d, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"a = %f, b = %f\nc = %d, d = %d\n"</span>, a, b, c, d);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>终端输出<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = 2.500000, b = 4.500000</div><div class="line">c = 100, d = 200</div><div class="line">a = 4.500000, b = 2.500000</div><div class="line">c = 200, d = 100</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="进阶——泛型Stack"><a href="#进阶——泛型Stack" class="headerlink" title="进阶——泛型Stack"></a>进阶——泛型Stack</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// stack.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">void</span> *elems;</div><div class="line">    <span class="keyword">int</span> elemSize;</div><div class="line">    <span class="keyword">int</span> logicalLength;</div><div class="line">    <span class="keyword">int</span> allocLength;</div><div class="line">    <span class="keyword">void</span> (*freefn)(<span class="keyword">void</span> *);	<span class="comment">// 用于释放元素时，元素不需要释放则是NULL</span></div><div class="line">&#125; <span class="built_in">stack</span>;</div><div class="line"></div><div class="line">void StackNew(stack *s, int elemSize, void (*freefn)(void *)); // 构造函数</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span></span>;                                   <span class="comment">// 析构函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(<span class="built_in">stack</span> *s, <span class="keyword">void</span> *elemAddr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(<span class="built_in">stack</span> *s, <span class="keyword">void</span> *elemAddr)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// stack.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line">void StackNew(stack *s, int elemSize, void (*freefn)(void *))</div><div class="line">&#123;</div><div class="line">    assert(elemSize &gt; <span class="number">0</span>);</div><div class="line">    s-&gt;elemSize = elemSize;</div><div class="line">    s-&gt;logicalLength = <span class="number">0</span>;</div><div class="line">    s-&gt;allocLength = <span class="number">4</span>;</div><div class="line">    s-&gt;elems = <span class="built_in">malloc</span>(<span class="number">4</span> * elemSize);</div><div class="line">    s-&gt;freefn = freefn;</div><div class="line">    assert(s-&gt;elems != <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDispose</span><span class="params">(<span class="built_in">stack</span> *s)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (s-&gt;freefn != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s-&gt;logicalLength; i++)</div><div class="line">        &#123;</div><div class="line">            s-&gt;freefn((<span class="keyword">char</span> *)s-&gt;elems + i * s-&gt;elemSize);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">free</span>(s-&gt;elems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StackGrow</span><span class="params">(<span class="built_in">stack</span> *s)</span> <span class="comment">// 供StackPush使用的辅助函数</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    s-&gt;allocLength *= <span class="number">2</span>;</div><div class="line">    s-&gt;elems = <span class="built_in">realloc</span>(s-&gt;elems, s-&gt;allocLength * s-&gt;elemSize);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(<span class="built_in">stack</span> *s, <span class="keyword">void</span> *elemAddr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (s-&gt;logicalLength == s-&gt;allocLength)</div><div class="line">    &#123;</div><div class="line">        StackGrow(s);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">void</span> *target = (<span class="keyword">char</span> *)s-&gt;elems + s-&gt;logicalLength * s-&gt;elemSize;</div><div class="line">    <span class="built_in">memcpy</span>(target, elemAddr, s-&gt;elemSize);</div><div class="line">    s-&gt;logicalLength++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(<span class="built_in">stack</span> *s, <span class="keyword">void</span> *elemAddr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    assert(s-&gt;logicalLength &gt; <span class="number">0</span>);</div><div class="line">    s-&gt;logicalLength--;</div><div class="line">    <span class="keyword">void</span> *source = (<span class="keyword">char</span> *)s-&gt;elems + s-&gt;logicalLength * s-&gt;elemSize;</div><div class="line">    <span class="built_in">memcpy</span>(elemAddr, source, s-&gt;elemSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用户代码示例"><a href="#用户代码示例" class="headerlink" title="用户代码示例"></a>用户代码示例</h2><ul>
<li><p>String</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringFree</span><span class="params">(<span class="keyword">void</span> *elem)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">free</span>(*(<span class="keyword">char</span> **)elem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">stack</span> stringStack;</div><div class="line">	StackNew(&amp;stringStack, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), StringFree);</div><div class="line"></div><div class="line">	<span class="keyword">char</span> *a;</div><div class="line">	a = strdup(<span class="string">"aaa"</span>);</div><div class="line">	StackPush(&amp;stringStack, &amp;a);</div><div class="line">	a = strdup(<span class="string">"bbb"</span>);</div><div class="line">	StackPush(&amp;stringStack, &amp;a);</div><div class="line">	a = strdup(<span class="string">"ccc"</span>);</div><div class="line">	StackPush(&amp;stringStack, &amp;a);</div><div class="line">	a = strdup(<span class="string">"ddd"</span>);</div><div class="line">	StackPush(&amp;stringStack, &amp;a);</div><div class="line"></div><div class="line">	<span class="keyword">char</span> *getString;</div><div class="line">	StackPop(&amp;stringStack, &amp;getString);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, getString);</div><div class="line">	<span class="built_in">free</span>(getString);</div><div class="line">	StackPop(&amp;stringStack, &amp;getString);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, getString);</div><div class="line">	<span class="built_in">free</span>(getString);</div><div class="line"></div><div class="line">	StackDispose(&amp;stringStack);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  终端输出</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ddd</div><div class="line">ccc</div></pre></td></tr></table></figure>
</li>
<li><p>Int</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">stack</span> intStack;</div><div class="line">	StackNew(&amp;intStack, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</div><div class="line">	&#123;</div><div class="line">		StackPush(&amp;intStack, &amp;i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> getInt;</div><div class="line">		StackPop(&amp;intStack, &amp;getInt);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, getInt);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"></div><div class="line">	StackDispose(&amp;intStack);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  终端输出</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8 7 6 5</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都说泛型是C++的一大特性，我大C语言表示不服&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
      <category term="C" scheme="http://gaufoo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>AppInventor2复刻FlappyBird</title>
    <link href="http://gaufoo.com/appinventor/"/>
    <id>http://gaufoo.com/appinventor/</id>
    <published>2017-12-08T08:13:19.000Z</published>
    <updated>2017-12-09T07:27:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>数字创意设计课程大作业。</p>
<a id="more"></a>
<hr>
<h1 id="画布、图像精灵控件的优点与缺陷"><a href="#画布、图像精灵控件的优点与缺陷" class="headerlink" title="画布、图像精灵控件的优点与缺陷"></a>画布、图像精灵控件的优点与缺陷</h1><ul>
<li>图像精灵只能放在画布内</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>自带与其他图像精灵的碰撞检测</li>
<li>具有自主行为：根据属性值进行移动、旋转</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>精灵的X、Y坐标不能取负值，换句话说，不能从屏幕左端、上端移出屏幕。这给动画实现带来困难。</li>
</ul>
<hr>
<h1 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h1><h2 id="小鸟飞行动画实现"><a href="#小鸟飞行动画实现" class="headerlink" title="小鸟飞行动画实现"></a>小鸟飞行动画实现</h2><p>将小鸟动作分解成一系列的图片，定时按序更换图片。<br><img src="/images/flappybird/bird.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><img src="/images/flappybird/bird1.png" width="500px"></p>
<hr>
<h2 id="地面移动动画模拟"><a href="#地面移动动画模拟" class="headerlink" title="地面移动动画模拟"></a>地面移动动画模拟</h2><p>地面图像的X坐标定时减少一小步，减少到特定值后跳回去一大步。换句话说，地面的移动轨迹会是 左左左右左左左右左左左右……<br>到这里，画布的缺陷导致需要有一块“幕布”来遮挡最左边的部分。<br><img src="/images/flappybird/moveground1.jpg"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="/images/flappybird/wall.png" width="500px"></p>
<hr>
<h2 id="小鸟控制实现"><a href="#小鸟控制实现" class="headerlink" title="小鸟控制实现"></a>小鸟控制实现</h2><p>表现：</p>
<ul>
<li>游戏开始后，触碰屏幕时，小鸟跳起，头朝上抬起</li>
<li>游戏开始后，不触碰屏幕时，小鸟受重力作用向下坠落，头往下垂</li>
</ul>
<p>实现：</p>
<ul>
<li>角度：点击屏幕，角度设为45度，再定时减少10度</li>
<li>位置：点击屏幕，速度设为负数（如-20），再定时 速度&lt;-加速度+速度，Y坐标&lt;-速度+Y坐标</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><img src="/images/flappybird/clickBird.png" width="500px"></p>
<hr>
<h2 id="柱子数据存储结构"><a href="#柱子数据存储结构" class="headerlink" title="柱子数据存储结构"></a>柱子数据存储结构</h2><p>一共有三组柱子，每组柱子里有上柱子、增分板（下文介绍它的作用）、下柱子。容易想到用二维数组来存储。<br><img src="/images/flappybird/pipes1.jpg"></p>
<p><img src="/images/flappybird/pipeStruct.png" width="500px"></p>
<hr>
<h2 id="无限柱子随机高度生成与移动"><a href="#无限柱子随机高度生成与移动" class="headerlink" title="无限柱子随机高度生成与移动"></a>无限柱子随机高度生成与移动</h2><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>这里利用图像精灵自带的方向、速度、时间间隔属性，让柱子自己移动。<br><img src="/images/flappybird/pipeproperty.png" width="500px"></p>
<h3 id="随机高度"><a href="#随机高度" class="headerlink" title="随机高度"></a>随机高度</h3><p>屏幕上方放有幕布。生成柱子时，上柱子的Y坐标在幕布高度范围内随机生成，增分板和下柱子依据上柱子的Y坐标计算而得。</p>
<h3 id="无限柱子"><a href="#无限柱子" class="headerlink" title="无限柱子"></a>无限柱子</h3><p>游戏初始化时，每组柱子在屏幕外排好。<br><img src="/images/flappybird/initpipes1.jpg"><br>当每组柱子到达屏幕最左边，让其直接跳到最右边柱子的右边（在屏幕外），用三组柱子模拟无限组柱子。<br><img src="/images/flappybird/movepipes1.jpg"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>柱子初始化<br><img src="/images/flappybird/initpipe.png" width="500px"><br>柱子到达最左边后更新<br><img src="/images/flappybird/p1.png" width="500px"><br><img src="/images/flappybird/p2.png" width="500px"><br><img src="/images/flappybird/p3.png" width="500px"></p>
<hr>
<h2 id="柱子与鸟碰撞检测"><a href="#柱子与鸟碰撞检测" class="headerlink" title="柱子与鸟碰撞检测"></a>柱子与鸟碰撞检测</h2><p>这里可以利用图像精灵自带的碰撞检测。另，控件自带碰撞检测是支撑我做这个项目的所有理由。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>鸟碰到任何一根柱子就GameOver<br><img src="/images/flappybird/birdcopipe.png" width="500px"></p>
<hr>
<h2 id="得分实现策略"><a href="#得分实现策略" class="headerlink" title="得分实现策略"></a>得分实现策略</h2><p>总算要提及奇怪的增分板的作用，其实是供小鸟碰撞，撞到后分数+1</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p><img src="/images/flappybird/getscore.png" width="500px"></p>
<hr>
<h2 id="标题显示模块"><a href="#标题显示模块" class="headerlink" title="标题显示模块"></a>标题显示模块</h2><p>选择时机更换标题图片并显示标题<br><img src="/images/flappybird/text_ready.png"><br><img src="/images/flappybird/text_game_over.png"><br><img src="/images/flappybird/title.png" width="500px"></p>
<hr>
<h2 id="分数显示模块"><a href="#分数显示模块" class="headerlink" title="分数显示模块"></a>分数显示模块</h2><p>分数包含10个十进制基数，所以要准备十张图片，分数更新时更新图片。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p><img src="/images/flappybird/score.png" width="500px"></p>
<hr>
<h2 id="分数结算板显示模块"><a href="#分数结算板显示模块" class="headerlink" title="分数结算板显示模块"></a>分数结算板显示模块</h2><p>显示所得分与最高分，最高分显然要用到微数据库，分数显示方法同上</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><p><img src="/images/flappybird/panel.png" width="500px"></p>
<hr>
<h1 id="驱动模块"><a href="#驱动模块" class="headerlink" title="驱动模块"></a>驱动模块</h1><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><ul>
<li>设置参数</li>
<li>初始化所有图片尺寸</li>
<li>初始化游戏</li>
</ul>
<p><img src="/images/flappybird/main.png" width="500px"></p>
<hr>
<h3 id="初始化所有图片尺寸"><a href="#初始化所有图片尺寸" class="headerlink" title="初始化所有图片尺寸"></a>初始化所有图片尺寸</h3><p><img src="/images/flappybird/initsize.png"></p>
<h4 id="初始化图片尺寸举例"><a href="#初始化图片尺寸举例" class="headerlink" title="初始化图片尺寸举例"></a>初始化图片尺寸举例</h4><p>地面<br><img src="/images/flappybird/initwallsize.png" width="500px"><br>柱子<br><img src="/images/flappybird/initpipesize.png" width="500px"></p>
<hr>
<h3 id="初始化游戏"><a href="#初始化游戏" class="headerlink" title="初始化游戏"></a>初始化游戏</h3><p>未开始游戏时的界面，有“Get Ready”标题。<br><img src="/images/flappybird/initgame.png"></p>
<hr>
<h4 id="初始化所有物件位置"><a href="#初始化所有物件位置" class="headerlink" title="初始化所有物件位置"></a>初始化所有物件位置</h4><p><img src="/images/flappybird/initloc1.png"><br><strong>举例</strong><br>标题<br><img src="/images/flappybird/inittitleloc.png" width="500px"><br>柱子<br><img src="/images/flappybird/initpipeloc.png" width="500px"></p>
<hr>
<h2 id="开始游戏"><a href="#开始游戏" class="headerlink" title="开始游戏"></a>开始游戏</h2><p>当游戏未开始时，触摸屏幕开始游戏。<br><img src="/images/flappybird/startgame.png" width="500px"></p>
<p>开始游戏，标题消失，分数显示，游戏元素启动。<br><img src="/images/flappybird/startgame1.png" width="500px"></p>
<hr>
<h2 id="游戏结束"><a href="#游戏结束" class="headerlink" title="游戏结束"></a>游戏结束</h2><p>当鸟碰到柱子时游戏结束。</p>
<p>定格画面，显示“Game Over”标题，更新最高分，显示分数结算板。<br><img src="/images/flappybird/gameover.png" width="500px"></p>
<hr>
<h1 id="辅助模块"><a href="#辅助模块" class="headerlink" title="辅助模块"></a>辅助模块</h1><p>主要是关于各物件的静止、启动、显示、隐藏。<br><img src="/images/flappybird/thingaux.png" width="500px"></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数字创意设计课程大作业。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://gaufoo.com/categories/Android/"/>
    
      <category term="AppInventor2" scheme="http://gaufoo.com/categories/Android/AppInventor2/"/>
    
    
      <category term="Android" scheme="http://gaufoo.com/tags/Android/"/>
    
      <category term="AppInventor2" scheme="http://gaufoo.com/tags/AppInventor2/"/>
    
  </entry>
  
  <entry>
    <title>RE转NFA，NFA转DFA</title>
    <link href="http://gaufoo.com/REtoNFAtoDFA/"/>
    <id>http://gaufoo.com/REtoNFAtoDFA/</id>
    <published>2017-10-29T12:09:54.000Z</published>
    <updated>2017-10-31T16:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单笔记</p>
<a id="more"></a>
<hr>
<h2 id="Thompson算法-——-RE-gt-NFA"><a href="#Thompson算法-——-RE-gt-NFA" class="headerlink" title="Thompson算法 —— RE -&gt; NFA"></a>Thompson算法 —— RE -&gt; NFA</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>基本的RE直接构造</li>
<li>复合的RE递归构造</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">e</div><div class="line">  -&gt; eps</div><div class="line">  -&gt; 单个字符c	// 前两种可以直接构造</div><div class="line">  -&gt; e1e2</div><div class="line">  -&gt; e1|e2</div><div class="line">  -&gt; e1*	// 后三种递归构造</div></pre></td></tr></table></figure>
<h3 id="eps"><a href="#eps" class="headerlink" title="eps"></a>eps</h3><p><img src="/images/vrhr/20171029202723.png"></p>
<h3 id="c"><a href="#c" class="headerlink" title="c"></a>c</h3><p><img src="/images/vrhr/20171029202934.png"></p>
<h3 id="e1e2"><a href="#e1e2" class="headerlink" title="e1e2"></a>e1e2</h3><p><img src="/images/vrhr/20171029203142.png"></p>
<h3 id="e1-e2"><a href="#e1-e2" class="headerlink" title="e1|e2"></a>e1|e2</h3><p><img src="/images/vrhr/20171029203543.png"></p>
<h3 id="e1"><a href="#e1" class="headerlink" title="e1*"></a>e1*</h3><p><img src="/images/vrhr/20171029203828.png"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote>
<p>a(b|c)*</p>
</blockquote>
<p><img src="/images/vrhr/20171029205037.png"></p>
<hr>
<h2 id="子集构造算法-——-NFA-gt-DFA"><a href="#子集构造算法-——-NFA-gt-DFA" class="headerlink" title="子集构造算法 —— NFA -&gt; DFA"></a>子集构造算法 —— NFA -&gt; DFA</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p><img src="/images/vrhr/20171029205037.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- 0 	  			 =&gt; 记为q0，添加进Q状态集中，下同</div><div class="line"></div><div class="line">- q0	——a——&gt; 1</div><div class="line">	==a(eps)==&gt; 1 2 3 4 6 *9 =&gt; 记为q1</div><div class="line"></div><div class="line">- q1	——b——&gt; 5				// delta(q1)集合，对每个q1元素的b通路</div><div class="line">	==b(eps)==&gt; 5 8 *9 3 4 6 =&gt; 记为q2	// eps-闭包(eps-closure)</div><div class="line">	——c——&gt; 7</div><div class="line">	==c(eps)==&gt; 7 8 *9 3 4 6 =&gt; 记为q3</div><div class="line">	</div><div class="line">- q2	——c——&gt; 7</div><div class="line">	==c(eps)==&gt; 7 8 9 3 4 6 == q3</div><div class="line">	——b——&gt; 5</div><div class="line">	==b(eps)==&gt; 5 8 9 3 4 6 == q2</div><div class="line"></div><div class="line">- q3	——b——&gt; 5</div><div class="line">	==b(eps)==&gt; 5 8 9 3 4 6 == q2</div><div class="line">	——c——&gt; 7</div><div class="line">	==c(eps)==&gt; 7 8 9 3 4 6 == q3</div></pre></td></tr></table></figure></p>
<p><img src="/images/vrhr/20171029211417.png"></p>
<h3 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h3><p>由上面的基本思想，容易得到以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">q0 &lt;- eps_closure(n0)</div><div class="line">Q &lt;- &#123;q0&#125;</div><div class="line">workList &lt;- q0</div><div class="line">while (!workList.empty())</div><div class="line">	q &lt;- workList.pop()</div><div class="line">	for each character c	// 256个ASCII码</div><div class="line">		t &lt;- eps_closure(delta(q, c))</div><div class="line">		if (t not in Q)</div><div class="line">			add t to Q</div><div class="line">			add t to workList</div><div class="line">		D[q, c] &lt;- t	// DFA记录此状态转换</div></pre></td></tr></table></figure></p>
<p>eps-闭包的计算：深度优先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set closure = &#123;&#125;</div><div class="line"></div><div class="line">void eps_closure(x)</div><div class="line">	closure += &#123;x&#125;</div><div class="line">	for each (y| x --eps--&gt; y)</div><div class="line">		if (!visited(y))</div><div class="line">			eps_closure(y)	// 递归</div></pre></td></tr></table></figure></p>
<p>eps-闭包的计算：宽度优先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">set closure = &#123;&#125;</div><div class="line">Q = []		// queue</div><div class="line"></div><div class="line">void eps_closure(x)</div><div class="line">	Q = [x]</div><div class="line">	while (!Q.empty())</div><div class="line">		q &lt;- Q.deQueue()</div><div class="line">		closure += q</div><div class="line">		for each (y| q --eps--&gt; y)</div><div class="line">			if (!visited(y))</div><div class="line">				Q.enQueue(y)</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单笔记&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="原理" scheme="http://gaufoo.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手工构造词法分析器</title>
    <link href="http://gaufoo.com/%E6%89%8B%E5%B7%A5%E6%9E%84%E9%80%A0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>http://gaufoo.com/手工构造词法分析器/</id>
    <published>2017-10-26T09:36:30.000Z</published>
    <updated>2017-10-30T00:45:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单笔记</p>
<a id="more"></a>
<hr>
<h2 id="记号数据结构"><a href="#记号数据结构" class="headerlink" title="记号数据结构"></a>记号数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Token的数据结构</span></div><div class="line"><span class="comment">// 将字符流转化成Token流</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> kind &#123;IF, LPAREN, ID, INTLIT, ...&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></div><div class="line">	<span class="keyword">enum</span> kind k;</div><div class="line">	<span class="keyword">char</span> lexeme[]; <span class="comment">// 单词</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>例：</p>
<blockquote>
<p>“if (x &gt; 5)”</p>
</blockquote>
<p>=&gt;<br>token {k = IF, lexeme = NULL};<br>// IF 和 “if” 一一对应，没必要记录单词<br>token {k = LPAREN, lexeme = NULL};<br>token {k = ID, lexeme = “x”};<br>…</p>
<hr>
<h2 id="转移图法"><a href="#转移图法" class="headerlink" title="转移图法"></a>转移图法</h2><h3 id="识别比较符"><a href="#识别比较符" class="headerlink" title="识别比较符"></a>识别比较符</h3><h4 id="转移图"><a href="#转移图" class="headerlink" title="转移图"></a>转移图</h4><p><img src="/images/cffx/20171026163706.png"></p>
<h4 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 上图的转换算法</div><div class="line"></div><div class="line">token nextToken()</div><div class="line">&#123;</div><div class="line">	c = getChar();</div><div class="line">	switch (c)</div><div class="line">	&#123;</div><div class="line">		case &apos;&lt;&apos;:</div><div class="line">			c = getChar();</div><div class="line">			switch(c)</div><div class="line">			&#123;</div><div class="line">				case &apos;=&apos;: return LE;</div><div class="line">				case &apos;&gt;&apos;: return NE;</div><div class="line">				default: rollback(); return LT;</div><div class="line">			&#125;</div><div class="line">		case &apos;=&apos;: return EQ;</div><div class="line">		case &apos;&gt;&apos;:</div><div class="line">			c = getChar();</div><div class="line">			switch(c)</div><div class="line">			&#123;</div><div class="line">				case &apos;=&apos;: return GE;</div><div class="line">				default: rollback(); return GT;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="识别标识符"><a href="#识别标识符" class="headerlink" title="识别标识符"></a>识别标识符</h3><h4 id="转移图-1"><a href="#转移图-1" class="headerlink" title="转移图"></a>转移图</h4><p><img src="/images/cffx/20171026165653.png"></p>
<h4 id="算法伪代码-1"><a href="#算法伪代码-1" class="headerlink" title="算法伪代码"></a>算法伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">token nextToken()</div><div class="line">&#123;</div><div class="line">	c = getChar();</div><div class="line">	switch (c)</div><div class="line">	&#123;</div><div class="line">	/*</div><div class="line">	...</div><div class="line">	...</div><div class="line">	...</div><div class="line">	*/</div><div class="line">	case &apos;a&apos;, ..., &apos;z&apos;, &apos;A&apos;, ..., &apos;Z&apos;, &apos;_&apos;:</div><div class="line">		c = getChar();</div><div class="line">		while (c == &apos;a&apos; || ... || c == &apos;z&apos; </div><div class="line">			|| c == &apos;A&apos; || ... || c == &apos;Z&apos;</div><div class="line">			|| c == &apos;0&apos; || ... || c == &apos;9&apos;</div><div class="line">			|| c == &apos;_&apos;)</div><div class="line">			c = getChar();</div><div class="line">		rollback();</div><div class="line">		return ID;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="识别IF"><a href="#识别IF" class="headerlink" title="识别IF"></a>识别IF</h4><p>在识别标识符的基础上，进一步实现识别特定的关键字。</p>
<h5 id="转移图-2"><a href="#转移图-2" class="headerlink" title="转移图"></a>转移图</h5><p><img src="/images/cffx/2017102617.png"></p>
<h5 id="算法伪代码-2"><a href="#算法伪代码-2" class="headerlink" title="算法伪代码"></a>算法伪代码</h5><p>代码太长太麻烦，我不想写。<br>如果对所有关键字都要写这样特定的代码，工作量显然是相当巨大的，于是便有了关键字表算法。</p>
<h4 id="关键字表算法"><a href="#关键字表算法" class="headerlink" title="关键字表算法"></a>关键字表算法</h4><ul>
<li>对所有关键字构造哈希表H</li>
<li>先统一按标识符的转移图来识别标识符</li>
<li>识别完成后，进一步查表H是否为关键字<br>通过合理的构造哈希表H（完美哈希），可以在O(1)时间完成。</li>
</ul>
<hr>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><blockquote>
<p>在这部分中，你将使用图转移算法手工实现一个小型的词法分析器。</p>
<ul>
<li>分析器的输入：存储在文本文件中的字符序列，字符取自ASCII字符集。文件中可能包括四种记号：关键字if、符合C语言标准的标识符、空格符、回车符\n。</li>
<li>分析器的输出：打印出所识别的标识符的种类、及行号、列号信息。</li>
</ul>
<p>【示例】对于下面的文本文件：<br>ifx if iif       if<br>iff     if<br>你的输出应该是：<br>ID(ifx) (1, 1)<br>IF        (1, 4)<br>ID(iif)  (1, 8)<br>IF       (1, 13)<br>ID(iff) (2, 1)<br>IF       (2, 8)</p>
</blockquote>
<p>我的代码（很恶心，但是不想改了）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Token(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> row, <span class="built_in">string</span>::size_type loc) : s(s), row(row), col(loc - s.size() + <span class="number">1</span>) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="built_in">string</span> str;</div><div class="line">        <span class="keyword">if</span> (s != <span class="string">"if"</span>)</div><div class="line">            str = <span class="string">"ID("</span> + s + <span class="string">")"</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            str = <span class="string">"IF"</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; str &lt;&lt; <span class="string">"\t("</span> &lt;&lt; row &lt;&lt; <span class="string">", "</span> &lt;&lt; col &lt;&lt; <span class="string">')'</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">int</span> row;</div><div class="line">    <span class="built_in">string</span>::size_type col;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> line;</div><div class="line">    <span class="keyword">int</span> cnt_line = <span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;Token&gt; tokens;</div><div class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, line))</div><div class="line">    &#123;</div><div class="line">        ++cnt_line;</div><div class="line">        <span class="built_in">string</span>::iterator cur = line.begin(), end = line.end();</div><div class="line">        <span class="keyword">while</span> (cur != end)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">string</span> id;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">isalpha</span>(*cur) || *cur == <span class="string">'_'</span>)</div><div class="line">            &#123;</div><div class="line">                id += *cur++;</div><div class="line">                <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*cur) || *cur == <span class="string">'_'</span>)</div><div class="line">                    id += *cur++;</div><div class="line">            &#125;</div><div class="line">            tokens.push_back(Token(id, cnt_line, cur - line.begin()));</div><div class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(*cur))</div><div class="line">                ++cur;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Token&gt;::iterator i = tokens.begin(); i != tokens.end(); ++i)</div><div class="line">        (*i).print();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出效果：<br><img src="/images/cffx/20171030084516.png"></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单笔记&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="原理" scheme="http://gaufoo.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++中三种实现可变参数的方法</title>
    <link href="http://gaufoo.com/Cpp%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>http://gaufoo.com/Cpp可变参数/</id>
    <published>2017-10-24T12:20:56.000Z</published>
    <updated>2017-10-24T17:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>我真的只是想写一个log函数而已。</p>
<a id="more"></a>
<hr>
<h2 id="可变参数宏（C实现）"><a href="#可变参数宏（C实现）" class="headerlink" title="可变参数宏（C实现）"></a>可变参数宏（C实现）</h2><p>利用头文件<code>stdarg.h</code>中的宏定义：<code>va_list</code>、<code>va_start(va_list, arg)</code>、<code>va_arg(va_list, type)</code>、<code>va_end(va_list)</code>。可以实现可变参数且参数类型不同的函数。</p>
<p>过程：</p>
<ul>
<li>函数声明中，可变参数用省略号表示。</li>
<li>创建<code>va_list</code>变量，通过<code>va_start</code>访问参数列表并承接第一个参数。</li>
<li>使用<code>va_arg</code>继续获取参数的值。</li>
<li>使用<code>va_end</code>完成清理工作。</li>
</ul>
<p>以可变参数版本的sum作为例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> <span class="comment">//count 表示可变参数个数</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    va_list ap;          <span class="comment">//声明一个va_list变量</span></div><div class="line">    va_start(ap, count); <span class="comment">//初始化，第二个参数为最后一个确定的形参（不能另开局部变量）</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">        sum += va_arg(ap, <span class="keyword">int</span>); <span class="comment">//读取可变参数，第二个参数为可变参数的类型</span></div><div class="line"></div><div class="line">    va_end(ap); <span class="comment">//清理工作</span></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>局限性：</p>
<blockquote>
<ul>
<li>可变参数宏只能实现<strong>顺序访问</strong>可变参数，无法后退访问。但可以重复使用<code>va_start</code>来初始化<code>va_list</code>变量。</li>
<li>运行时，函数必须能够根据已有信息（既有约定，或确定实参）确定可变参数的具体个数与类型：函数定义需要知道可变参数的具体类型、个数，这些信息是在运行时确定的，那么显然应该由实参来确定。在上面的例子中count传递了可变参数的个数，而参数类型则是既有约定（整型）； </li>
<li>该方法是<strong>极不安全</strong>的，宏本身无法提供任何安全性保证，他总是按照既定代码“自作多情”的认为实参就应该是那么多，即使实参并不是那么多。这就要求所有安全性必须由程序员来保证。例如，在以上的示例代码中，如果调用时指定count为10，但实际上只给出9个可变形参，那么函数还是会读取10个参数，显然第十次读取是多余的，多余的操作一般不会有什么好结果，当然如果实参过多，多余的实参也不会被读取而是被忽略。</li>
</ul>
</blockquote>
<hr>
<h2 id="initializer-list标准库类型（C-11）"><a href="#initializer-list标准库类型（C-11）" class="headerlink" title="initializer_list标准库类型（C++11）"></a>initializer_list标准库类型（C++11）</h2><p>过程：</p>
<ul>
<li>函数声明中使用<code>initializer_list</code>模板代表可变参数列表</li>
<li>使用迭代器访问<code>initializer_list</code>中的参数</li>
<li>传入参数时需要使用<code>{}</code>把多个参数括起来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : il)   <span class="comment">// 使用范围for</span></div><div class="line">        sum += p;</div><div class="line">    <span class="comment">// for (auto p = il.begin(); p != il.end(); p++) //使用迭代器访问参数</span></div><div class="line">    <span class="comment">//     sum += *p;</span></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>局限性：</p>
<ul>
<li>可变参数类型必须<strong>一致</strong></li>
</ul>
<hr>
<h2 id="可变参数模板（C-11）"><a href="#可变参数模板（C-11）" class="headerlink" title="可变参数模板（C++11）"></a>可变参数模板（C++11）</h2><p>更方便安全有效地实现可变参数且参数类型不同的函数。</p>
<p>过程：</p>
<ul>
<li>编写含有模板参数包和函数参数包的模板函数</li>
<li>函数定义<strong>递归</strong>调用自己</li>
<li>利用函数重载（参数包含有零个参数）来处理<strong>边界情况</strong>，编写处理边界情况的模板</li>
</ul>
<p>C++ primer 第五版中的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></div><div class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明（否则将出现neither visible nor found by argument-dependent lookup错误）</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> os &lt;&lt; t;                <span class="comment">// 包中最后一个元素</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//包中除最后一个元素之外的其他元素都会调用这个版本的pirnt</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> T &amp;t, cosnt Args &amp;... rest)</span></span>&#123;</div><div class="line">    os &lt;&lt; t &lt;&lt; <span class="string">","</span>;               <span class="comment">// 打印第一个实参，包中元素减一</span></div><div class="line">    <span class="keyword">return</span> print(os, rest...);    <span class="comment">// 递归调用，打印剩余实参</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>局限性：</p>
<ul>
<li>由于只能递归实现，导致需要定义重载函数来处理边界情况，代码不够清晰自然。</li>
<li>模板会为每一个不同的实例生成代码，函数的实例过多可能会使代码体积庞大。</li>
<li>依靠递归使得功能具有局限性，并且效率也会受到影响。</li>
</ul>
<hr>
<h2 id="log函数实现"><a href="#log函数实现" class="headerlink" title="log函数实现"></a>log函数实现</h2><p>头文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* log.h */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOG_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">log</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; &#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">log</span><span class="params">(T <span class="keyword">const</span> &amp;p, Args <span class="keyword">const</span> &amp;... rest)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">log</span>(rest...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* test.cpp */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</div><div class="line">    <span class="built_in">log</span>(n, <span class="string">" hello "</span>, <span class="number">10086</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// std::cout &lt;&lt; "2 hello 10086" &lt;&lt; std::endl;</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我真的只是想写一个log函数而已。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
      <category term="编程" scheme="http://gaufoo.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/tags/C/"/>
    
      <category term="C" scheme="http://gaufoo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11类型说明符：constexpr</title>
    <link href="http://gaufoo.com/CppConstexpr/"/>
    <id>http://gaufoo.com/CppConstexpr/</id>
    <published>2017-10-24T08:00:59.000Z</published>
    <updated>2017-10-24T11:39:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字<code>constexpr</code>用于修饰常量表达式（const express），具体说明如下</p>
<a id="more"></a>
<hr>
<h2 id="字面值常量（literal）"><a href="#字面值常量（literal）" class="headerlink" title="字面值常量（literal）"></a>字面值常量（literal）</h2><ul>
<li>由形式和值来决定数据类型</li>
<li>可手动指定类型<br>如：<ul>
<li>常规<br>20 <em>—— 十进制数</em><br>0x8 <em>—— 十六进制数</em><br>“hello” <em>—— char[6]</em></li>
<li>指定类型<br>3F <em>—— float</em><br>L’a’ <em>—— whar_t</em><br>u8”hi!” <em>—— utf-8</em><br>3.14159 <em>—— long double</em></li>
</ul>
</li>
</ul>
<hr>
<h2 id="常量表达式（const-express）"><a href="#常量表达式（const-express）" class="headerlink" title="常量表达式（const express）"></a>常量表达式（const express）</h2><blockquote>
<p>The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given). A <code>constexpr</code> specifier used in an <code>object</code> declaration implies <code>const</code>. A <code>constexpr</code> specifier used in a <code>function</code> or static member variable (since C++17) declaration implies <code>inline</code>.</p>
</blockquote>
<p>其中<code>literal</code>就是<code>const express</code>的一种。从文档可知，<code>const express</code>主要性质是可以在编译期间得到值。同时，<code>constexpr</code>修饰的对象自动获得<strong>常量</strong>属性，<code>constexpr</code>修饰的函数自动获得<strong>内联</strong>属性。</p>
<hr>
<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><p>满足以下条件：</p>
<ul>
<li>其值必须为<code>literal</code>类型。</li>
<li>必须能立即初始化，意味着所有的初始化方法，包括所有隐式转换、调用构造函数等，都必须为<code>const express</code>。</li>
</ul>
<p>特别需要说明的是指针变量，<code>constexpr</code>类型的指针变量有以下的几种存在方式：</p>
<ul>
<li><p>指向nullptr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>指向全局变量、static变量，因其地址不会改变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;	<span class="comment">// i 定义在函数外部，是一个全局变量</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p = &amp;i;	<span class="comment">// 正确</span></div></pre></td></tr></table></figure>
</li>
<li><p>另外：<br>虽然<code>constexpr</code>和<code>const</code>在某些方面有点相似，但<code>constexpr int *q = nullptr;</code>的含义却与<code>const int *q = nullptr;</code>的有些出入，前者<code>q</code>不能修改，后者<code>*q</code>不能修改。若需要指向常量的常量指针，可以这样定义：<code>constexpr const int *q = nullptr;</code>，这样<code>q</code>和<code>*q</code>就都是不可修改的常量了。</p>
</li>
</ul>
<hr>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p><code>constexpr</code>函数会被隐式地<code>inline</code>。<br>满足以下条件：</p>
<ul>
<li>形参和返回值都得为<code>literal</code>类型</li>
<li>只能有一条<code>return</code>语句</li>
</ul>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</div><div class="line"><span class="function">cosntexpr size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123;<span class="keyword">return</span> new_sz() * cnt;&#125;</div><div class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)];	<span class="comment">// 正确，scale(2)是const express</span></div><div class="line"><span class="keyword">int</span> n = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> arr2[scale(n)];	<span class="comment">// 错误，scale(n)不是const express</span></div></pre></td></tr></table></figure></p>
<hr>
<h3 id="constexpr类"><a href="#constexpr类" class="headerlink" title="constexpr类"></a>constexpr类</h3><p>满足以下条件：</p>
<ul>
<li>该类是聚合类，所谓聚合类：<ul>
<li>所有成员都是public</li>
<li>无显式定义的构造函数</li>
<li>成员无初始值</li>
<li>无基类，无virtual函数</li>
</ul>
</li>
<li>若不是聚合类，需要满足<ul>
<li>数据成员必须都为<code>literal</code>类型（函数成员无须是）</li>
<li>至少含有一个<code>constexpr</code>构造函数</li>
<li>只能使用默认的析构函数</li>
</ul>
</li>
</ul>
<p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    constexpr Debug(bool b = true) : hw(b), io(b), other(b) &#123;&#125;</div><div class="line">    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hw || io || other; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_io</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; io = b; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_hw</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; hw = b; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_other</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; other = b; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">bool</span> hw;</div><div class="line">    <span class="keyword">bool</span> io;</div><div class="line">    <span class="keyword">bool</span> other;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span></span>;</div><div class="line">    <span class="keyword">if</span> (io_sub.any())</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"print appropriate error messages"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字&lt;code&gt;constexpr&lt;/code&gt;用于修饰常量表达式（const express），具体说明如下&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
      <category term="编程" scheme="http://gaufoo.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://gaufoo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>编译原理学习笔记（二）</title>
    <link href="http://gaufoo.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://gaufoo.com/编译原理学习笔记（二）/</id>
    <published>2017-09-16T09:46:00.000Z</published>
    <updated>2017-10-27T01:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录</p>
<a id="more"></a>
<hr>
<h2 id="正则表达式-Regular-Expression，RE"><a href="#正则表达式-Regular-Expression，RE" class="headerlink" title="正则表达式 ( Regular Expression，RE )"></a>正则表达式 ( Regular Expression，RE )</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>是一种用来描述正则语言的更紧凑的表示方法。</li>
<li>正则表达式可以由较小的正则表达式按照特定规则<strong>递归</strong>地构建。</li>
<li>每个正则表达式 <strong>r</strong> 定义(表示)一个语言，记为 <strong>L(r)</strong> 。</li>
</ul>
<hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>ε是一个RE，L(ε) = {ε}</li>
<li>如果 a∈∑，则a是一个RE，L(a) = {a}</li>
<li>假设 <strong>r</strong> 和 <strong>s</strong> 都是RE，表示的语言分别是 <strong>L(r)</strong> 和 <strong>L(s)</strong> ，则<ul>
<li>r|s 是一个RE，L( r|s ) = L(r)∪L(s)</li>
<li>rs 是一个RE，L( rs ) = L(r) L(s)</li>
<li>r* 是一个RE，L( r* )= (L(r))*</li>
<li>(r) 是一个RE，L( (r) ) = L(r)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>C语言无符号整数的RE</p>
<ul>
<li>十进制整数的RE - (1|…|9)(0|…|9)*|0</li>
<li>八进制整数的RE - 0(0|1|2|3|4|5|6|7)(0|1|2|3|4|5|6|7)*</li>
<li>十六进制整数的RE - 0x(0|1|…|9|a|…| f |A|…|F)(0|…|9|a|…| f |A|…|F )*</li>
</ul>
<hr>
<h3 id="代数定律"><a href="#代数定律" class="headerlink" title="代数定律"></a>代数定律</h3><table>
<thead>
<tr>
<th>定律</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r｜s = s｜r</td>
<td>｜是可以交换的</td>
</tr>
<tr>
<td>r｜( s｜t )=( r｜s )｜t</td>
<td>｜是可结合的</td>
</tr>
<tr>
<td>r(s t)=( r s)t</td>
<td>连接是可结合的</td>
</tr>
<tr>
<td>r ( s｜t )= r s｜r t ; &nbsp;&nbsp;&nbsp; ( s｜t ) r = sr｜t r</td>
<td>连接对｜是可分配的</td>
</tr>
<tr>
<td>εr = rε = r</td>
<td>ε 是连接的单位元</td>
</tr>
<tr>
<td>r* = ( r｜ε )*</td>
<td>闭包中一定包含 ε</td>
</tr>
<tr>
<td>r* * = r*</td>
<td>* 具有幂等性</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="单词的识别"><a href="#单词的识别" class="headerlink" title="单词的识别"></a>单词的识别</h2><h3 id="有穷自动机-Finite-Automata，FA"><a href="#有穷自动机-Finite-Automata，FA" class="headerlink" title="有穷自动机 ( Finite Automata，FA )"></a>有穷自动机 ( Finite Automata，FA )</h3><ul>
<li>具有一系列<strong>离散的输入输出信息</strong>和<strong>有穷数目的内部状态</strong>。</li>
<li>系统只需要根据<strong>当前所处的状态</strong>和<strong>当前面临的输入信息</strong>就可以决定系统的<strong>后继行为</strong>。</li>
<li>每当系统处理了当前的输入后，系统的内部状态也将<strong>发生改变</strong>。</li>
</ul>
<h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p><img src="/images/20170916182343.jpg" width="500"></p>
<ul>
<li>输入带(input tape)：用来存放输入符号串。</li>
<li>读头(head )：从左向右逐个读取输入符号，不能修改（只读）、不能往返移动。</li>
<li>有穷控制器( finite control )：具有有穷个状态数，根据<strong>当前的状态</strong>和<strong>当前输入符号</strong>控制转入<strong>下一状态</strong>。</li>
</ul>
<h4 id="表示：转换图-Transition-Graph"><a href="#表示：转换图-Transition-Graph" class="headerlink" title="表示：转换图 ( Transition Graph )"></a>表示：转换图 ( Transition Graph )</h4><p><img src="/images/20170916183203.jpg" width="500"></p>
<ul>
<li>结点：FA的状态<ul>
<li>初始状态（开始状态）：<strong>只有一个</strong>，由start箭头指向。</li>
<li>终止状态（接收状态）：可以有多个，用<strong>双圈</strong>表示。</li>
</ul>
</li>
<li>带标记的有向边：如果对于输入 <strong>a</strong> ，存在一个从状态 <strong>p</strong> 到状态 <strong>q</strong> 的转换，就在 <strong>p</strong> 、 <strong>q</strong> 之间画一条有向边，并标记上 <strong>a</strong> 。</li>
</ul>
<h4 id="接收的语言"><a href="#接收的语言" class="headerlink" title="接收的语言"></a>接收的语言</h4><ul>
<li>给定输入串 <strong>x</strong> ，如果存在一个对应于串 <strong>x</strong> 的从初始状态到某个终止状态的转换序列，则称串 <strong>x</strong> 被该FA接收。</li>
<li>由一个有穷自动机M接收的所有串构成的集合称为是该<strong>FA定义（或接收）的语言</strong>，记为 <strong>L( M )</strong>。</li>
</ul>
<p><img src="/images/20170916183203.jpg" width="500"></p>
<blockquote>
<p>L(M) = 所有以abb结尾的字母表{a, b}上的串的集合</p>
</blockquote>
<h4 id="最长子串匹配原则"><a href="#最长子串匹配原则" class="headerlink" title="最长子串匹配原则"></a>最长子串匹配原则</h4><p>当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配。</p>
<hr>
<h3 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h3><ul>
<li>确定的FA (Deterministic finite automata, DFA)</li>
<li>非确定的FA (Nondeterministic finite automata, NFA)</li>
</ul>
<h4 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h4><p>对任意的字符，最多有一个状态可以转移。</p>
<p><strong>M = ( S，Σ ，δ，s0，F )</strong></p>
<ul>
<li>S：有穷状态集。</li>
<li>Σ：输入字母表，即输入符号集合。假设 <strong>ε</strong> 不是 Σ 中的元素。</li>
<li>δ：将S×Σ映射到S的<strong>转换函数</strong>。∀s∈S, a∈Σ, <strong>δ(s,a)</strong> 表示从状态s出发，沿着标记为a的边所能到达的状态。</li>
<li>s0：开始状态 (或初始状态)，s0∈ S。</li>
<li>F：接收状态（或终止状态）集合，F⊆ S。</li>
</ul>
<p><img src="/images/DFA.png" width="500"></p>
<blockquote>
<p>r = (a|b)*abb</p>
</blockquote>
<hr>
<h4 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h4><p>对任意的字符，有多于一个状态可以转移。</p>
<p><strong>M = ( S，Σ ，δ，s0，F )</strong></p>
<ul>
<li>S：有穷状态集。</li>
<li>Σ：输入字母表，即输入字母表。假设 <strong>ε</strong> 不是 Σ 中的元素。</li>
<li>δ：将S×Σ映射到2^S的<strong>转换函数</strong>。s∈S, a∈Σ, <strong>δ(s,a)</strong>表示从状态s出发，沿着标记为a的边所能到达的状态集合。</li>
<li>s0：开始状态 (或初始状态)，s0∈ S。</li>
<li>F：接收状态（或终止状态）集合，F⊆ S。</li>
</ul>
<p><img src="/images/NFA.png" width="500"></p>
<blockquote>
<p>r = (a|b)*abb</p>
</blockquote>
<hr>
<h4 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h4><blockquote>
<p>对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D<br>对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N</p>
</blockquote>
<hr>
<h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><ul>
<li>对于DFA，一个特定的符号输入，有且只能得到一个状态，而NFA就有可能得到一个状态集。因此NFA引擎必须记录所有的可能路径。</li>
<li>DFA比较快，但不提供Backtrack（回溯）功能，NFA比较慢，但提供了Backtrack功能。</li>
</ul>
<hr>
<h4 id="DFA的算法实现"><a href="#DFA的算法实现" class="headerlink" title="DFA的算法实现"></a>DFA的算法实现</h4><p>由于DFA对于特定输入，状态是确定的，因此实现起来很方便。</p>
<ul>
<li>输入：以文件结束符<strong>eof</strong>结尾的字符串<strong>x</strong>。DFA <strong>D</strong>的开始状态<strong>s0</strong>，接收状态集<strong>F</strong>，转换函数<strong>move</strong>。</li>
<li>输出：如果<strong>D</strong>接收<strong>x</strong>，则回答“yes”，否则回答“no”。</li>
<li>方法：将下述算法应用于输入串<strong>x</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">s = s0;</div><div class="line">c = next_char();</div><div class="line">while (c != eof) &#123;</div><div class="line">	s = move(s, c);</div><div class="line">	c = next_char();</div><div class="line">&#125;</div><div class="line">if (s is in F)</div><div class="line">	return &quot;yes&quot;;</div><div class="line">else</div><div class="line">	return &quot;no&quot;;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="RE转换成NFA"><a href="#RE转换成NFA" class="headerlink" title="RE转换成NFA"></a>RE转换成NFA</h3><h4 id="ε"><a href="#ε" class="headerlink" title="ε"></a>ε</h4><p><img src="/images/20171024144829.png" width="400"></p>
<h4 id="字母表Σ中符号a"><a href="#字母表Σ中符号a" class="headerlink" title="字母表Σ中符号a"></a>字母表Σ中符号a</h4><p><img src="/images/20171024144915.png" width="400"></p>
<h4 id="r-r1r2"><a href="#r-r1r2" class="headerlink" title="r = r1r2"></a>r = r1r2</h4><p><img src="/images/20171024145410.png" width="500"></p>
<h4 id="r-r1-r2"><a href="#r-r1-r2" class="headerlink" title="r = r1|r2"></a>r = r1|r2</h4><p><img src="/images/20171024145504.png" width="400"></p>
<h4 id="r-r1"><a href="#r-r1" class="headerlink" title="r = (r1)*"></a>r = (r1)*</h4><p><img src="/images/20171024145520.png" width="200"></p>
<hr>
<blockquote>
<p>r=(a|b)*abb 对应的NFA</p>
</blockquote>
<p><img src="/images/20171024150046.png" width="500"></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="原理" scheme="http://gaufoo.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理学习笔记（一）</title>
    <link href="http://gaufoo.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://gaufoo.com/编译原理学习笔记（一）/</id>
    <published>2017-09-09T17:52:49.000Z</published>
    <updated>2017-09-16T10:05:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录</p>
<a id="more"></a>
<hr>
<h2 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h2><p><strong>G = (V<sub>T</sub>, V<sub>N</sub>, P , S )</strong></p>
<h3 id="各成分含义"><a href="#各成分含义" class="headerlink" title="各成分含义"></a>各成分含义</h3><ul>
<li>V<sub>T</sub>：终结符集合<ul>
<li>终结符（terminal symbol）是文法所定义的语言的<strong>基本符号</strong>，有时也称为token</li>
<li>例：V<sub>T</sub> = { apple, boy, eat, little }</li>
</ul>
</li>
<li><p>V<sub>N</sub>：非终结符集合</p>
<ul>
<li>非终结符 ( nonterminal ) 是用来表示<strong>语法成分</strong>的符号，有时也称为“语法变量”</li>
<li><p>例: V<sub>N</sub> = { &lt;句子&gt;, &lt;名词短语&gt;, &lt;动词短语&gt;, &lt;名词&gt;, … }</p>
<blockquote>
<p>V<sub>T</sub> ∩ V<sub>N</sub> = Φ<br>V<sub>T</sub> ∪ V<sub>N</sub> = 文法符号集</p>
</blockquote>
</li>
</ul>
</li>
<li><p>P：产生式集合</p>
<ul>
<li>产生式 ( production ) 描述了将终结符和非终结符组合成串的方法</li>
<li>产生式的一般形式： <strong>α→β</strong> ，读作：α定义为β<ul>
<li>α∈(V<sub>T</sub> ∪ V<sub>N</sub> )<sup>+</sup>，且α中至少包含V<sub>N</sub>中的一个元素：称为产生式的头 ( head ) 或左部 ( left side )</li>
<li>β∈(V<sub>T</sub> ∪ V<sub>N</sub> )<sup>*</sup>：称为产生式的体(body)或右部(right side)</li>
</ul>
</li>
<li>例：{&lt;句子&gt;→&lt;名词短语&gt;&lt;动词短语&gt;,&lt;名词短语&gt;→&lt;形容词&gt;&lt;名词短语&gt;,……}</li>
</ul>
</li>
<li>S：开始符号<ul>
<li>S∈V<sub>N</sub> 。开始符号 ( start symbol ) 表示的是该文法中<strong>最大</strong>的语法成分</li>
<li>例：S = &lt;句子&gt;</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>例子：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">G = (&#123;id, +, *, (, )&#125;, &#123;E&#125;, P, E)</div><div class="line">P = &#123;	E → E + E,</div><div class="line">	E → E * E,</div><div class="line">	E → ( E ),</div><div class="line">	E → id&#125;</div></pre></td></tr></table></figure>
<p>  约定：不引起歧义的前提下，可以只写产生式</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">G : 	E → E + E</div><div class="line">	E → E * E</div><div class="line">	E → ( E )</div><div class="line">	E → id</div></pre></td></tr></table></figure>
<p>  简写：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">G : E → E + E | E * E | ( E ) | id</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><ul>
<li>终结符<ul>
<li>字母表中排在前面的小写字母，如 a、b、c</li>
<li>运算符，如 +、*等</li>
<li>标点符号，如括号、逗号等</li>
<li>数字 0、1、… 、9</li>
<li>粗体字符串，如<strong>id</strong>、<strong>if</strong>等</li>
</ul>
</li>
<li>非终结符<ul>
<li>字母表中排在前面的大写字母，如A、B、C</li>
<li>字母S。通常表示开始符号</li>
<li>小写、斜体的名字，如 <em>expr</em>、<em>stmt</em>等</li>
<li>代表程序构造的大写字母。如E(表达式)、T(项)和F(因子)</li>
</ul>
</li>
<li>文法符号（即终结符或非终结符）<ul>
<li>字母表中排在后面的大写字母（如X、Y、Z）</li>
</ul>
</li>
<li>终结符号串<ul>
<li>字母表中排在后面的小写字母（主要是u、v、… 、z）</li>
</ul>
</li>
<li>文法符号串<ul>
<li>小写希腊字母，如α、β、γ</li>
</ul>
</li>
<li>除非特别说明，第一个产生式的左部就是开始符号</li>
</ul>
<hr>
<h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导和归约"><a href="#推导和归约" class="headerlink" title="推导和归约"></a>推导和归约</h3><p>用产生式的右部替换产生式的左部，称为推导 (Derivations) </p>
<blockquote>
<p>如果α0=&gt;α1，α1=&gt;α2，α2=&gt;α3，…，α n-1=&gt;αn，则可以记作α0=&gt;α1=&gt;α2=&gt;α3=&gt; …=&gt; α n-1=&gt;αn，称符号串 α0经过n步推导出αn，可简记为α0=&gt;<sup>n</sup>αn</p>
</blockquote>
<p>用产生式的左部替换产生式的右部，称为归约 (Reductions)<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;句子&gt; =&gt; &lt;名词短语&gt;&lt;动词短语&gt;</div><div class="line">       =&gt; &lt;形容词&gt;&lt;名词短语&gt;&lt;动词短语&gt;</div><div class="line">       =&gt; little &lt;名词短语&gt;&lt;动词短语&gt;</div><div class="line">       =&gt; little &lt;名词&gt;&lt;动词短语&gt;</div><div class="line">       =&gt; little boy &lt;动词短语&gt;</div><div class="line">       =&gt; little boy &lt;动词&gt;&lt;名词短语&gt;</div><div class="line">       =&gt; little boy eats &lt;名词短语&gt;</div><div class="line">       =&gt; little boy eats &lt;名词&gt;</div><div class="line">       =&gt; little boy eats apple</div></pre></td></tr></table></figure></p>
<p>由上往下是推导，由下往上是归约</p>
<hr>
<h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><ul>
<li>如果 S=&gt;*α, α∈(V<sub>T</sub>∪V<sub>N</sub>)*，则称α是G的一个句型(sentential form)</li>
<li>如果 S=&gt;*w，w∈V<sub>T</sub>*，则称w是G的一个句子(sentence)</li>
</ul>
<blockquote>
<p>句子是不包含<strong>非终结符</strong>的句型</p>
</blockquote>
<ul>
<li>由文法G的开始符号S推导出的所有<strong>句子</strong>构成的集合称为文法G生成的<strong>语言</strong>，记为L(G)。</li>
</ul>
<hr>
<h2 id="Chomsky-文法分类体系"><a href="#Chomsky-文法分类体系" class="headerlink" title="Chomsky 文法分类体系"></a>Chomsky 文法分类体系</h2><h3 id="0型文法-Type-0-Grammar"><a href="#0型文法-Type-0-Grammar" class="headerlink" title="0型文法 (Type-0 Grammar)"></a>0型文法 (Type-0 Grammar)</h3><ul>
<li>无限制文法(Unrestricted Grammar) / 短语结构文法(Phrase Structure Grammar, PSG )<ul>
<li>∀α → β∈P， α中至少包含1个非终结符</li>
</ul>
</li>
</ul>
<blockquote>
<p>PSG中可包含ε-产生式</p>
</blockquote>
<hr>
<h3 id="1型文法-Type-1-Grammar"><a href="#1型文法-Type-1-Grammar" class="headerlink" title="1型文法 (Type-1 Grammar)"></a>1型文法 (Type-1 Grammar)</h3><ul>
<li>上下文有关文法(Context-Sensitive Grammar , CSG )<ul>
<li>∀α → β∈P，｜α｜≤｜β｜</li>
<li>产生式的一般形式： α1Aα2 → α1βα2 ( β≠ε )</li>
</ul>
</li>
</ul>
<blockquote>
<p>CSG中不包含ε-产生式</p>
</blockquote>
<hr>
<h3 id="2型文法-Type-2-Grammar"><a href="#2型文法-Type-2-Grammar" class="headerlink" title="2型文法 (Type-2 Grammar)"></a>2型文法 (Type-2 Grammar)</h3><ul>
<li>上下文无关文法 (Context-Free Grammar, CFG )<ul>
<li>∀α → β∈P，α ∈ V<sub>N</sub></li>
<li>产生式的一般形式：A→β</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3型文法-Type-3-Grammar"><a href="#3型文法-Type-3-Grammar" class="headerlink" title="3型文法 (Type-3 Grammar)"></a>3型文法 (Type-3 Grammar)</h3><ul>
<li>正则文法 (Regular Grammar, RG )<ul>
<li>右线性(Right Linear)文法： A→wB 或 A→w</li>
<li>左线性(Left Linear) 文法： A→Bw 或 A→w</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四种文法之间的关系"><a href="#四种文法之间的关系" class="headerlink" title="四种文法之间的关系"></a>四种文法之间的关系</h3><p>逐级限制：</p>
<ul>
<li>0型文法：α中至少包含1个非终结符</li>
<li>1型文法（CSG） ：｜α｜≤｜β｜</li>
<li>2型文法（CFG） ：α ∈ V<sub>N</sub></li>
<li>3型文法（RG）：A→wB 或 A→w (A→Bw 或A→w)</li>
</ul>
<hr>
<h2 id="CFG的分析树"><a href="#CFG的分析树" class="headerlink" title="CFG的分析树"></a>CFG的分析树</h2><h3 id="分析树举例"><a href="#分析树举例" class="headerlink" title="分析树举例"></a>分析树举例</h3><p><img src="/images/229534388000563683.jpg" width="500"></p>
<ul>
<li>分析树是推导的图形化表示<br>  推导过程：E =&gt; -E =&gt; - ( E ) =&gt; - ( E+E ) =&gt; - ( id+E ) =&gt; - ( id+id )</li>
<li>结构<ul>
<li><strong>根节点</strong>的标号为<strong>文法开始符号</strong></li>
<li><strong>内部结点</strong>表示对一个产生式A→β的应用，该结点的标号是此产生式左部<strong>A</strong>。该结点的子结点的标号从左到右构成了产生式的右部<strong>β</strong></li>
<li><strong>叶结点</strong>的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点得到的符号串称为是这棵树的产出(yield)或边缘(frontier)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的</p>
<p>例：<br>文法：S → <strong>if</strong> E <strong>then</strong> S | <strong>if</strong> E <strong>then</strong> S <strong>else</strong> S | <strong>other</strong><br>句型：<strong>if</strong> E1 <strong>then</strong> <strong>if</strong> E2 <strong>then</strong> S1 <strong>else</strong> S2<br>    可生成的分析树有：<br><img src="/images/728669562437023693.jpg" width="500"></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录&lt;/p&gt;
    
    </summary>
    
      <category term="原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/categories/%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="原理" scheme="http://gaufoo.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译原理" scheme="http://gaufoo.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
